package concurrency;//: concurrency/LiftOff.java
// Demonstration of the Runnable interface.


/****
 *
 *
 * 到目前为止，你学到的都是有关顺序编程的知识，即程序中所有的事物在任意时刻都只能执行一个步骤
 * 编程问题中相当大的一部分可以通过顺序编程来解决，然而对于某些问题，如果能够并行执行程序中的多个
 * 部分，则会变得非常方便甚至非常必要，因为这些部分要么看起来在并发执行，要么多处理器环境下可能同
 * 时执行。
 * 并行编程可以使程序的执行速度得到极大的提高，或者为设计某些类型的程序提供更易用的模型，或者两者
 * 皆有，但是，熟练的掌握并发编程理论技术，对于到目前为止你在本书中学习到的所有的知识是一种飞跃。
 * 并且是通向高级主题的中介，本章只能作为一个介绍，即便融会贯通了本章的内容，也绝不意味着你就是一个
 * 作秀的程序员了。
 * 正如你应该看到的，当并行执行的任务彼此开始产生互相干涉时，实际的并发问题就会接踵而至，这可能是一种
 * 微妙的偶然的关系发生，我们可以很公正的地说，并发 "并发具有可论证的确定性，但实际上具有不可能定性"
 * 这就是说，你可以很公正的得出结论，通过仔细的设计和代码的审查，编写能够正确的工作的并发程序是可能的
 * ，但是，实际情况中，更容易发生的情况是所编写的并发程序在给定适当的条件的时候，将会工作失败，这些条件
 * 可能从来都不会实际发生，或者发生得不是很频繁，以至于在测试代码中不会碰上它们，实际上，你可能编写出能
 * 够针对你的并发程序生成故障条件的测试代码，所产生的故障经常是偶尔发生的，并且经常是以客户抱怨的形式
 * 出现的，这是研究并发问题的最强理由，如果你视而不见，你就会遭其反噬
 * 因此，并发看起来充满危险，如果你对它有些畏惧，这可能是件好事，尽管java SE5在并发方面是做出了显著的
 * 改进，但是仍旧没有像编译期验证或检查型异常这样的安全网，在你犯下错误的时候告知你，使用并发时，你得
 * 自食其力，并且只有变得多疑而自信，才能用Java编写出可靠的多线程代码。
 * 有时人们会认为并发对于介绍语言的书来说是太高级了，因此不适合放在其中，他们认为并发是一个独立的主题，可以用特殊的
 * 的惯用法来处理，如果你可以回避，为什么还要介绍这么复杂的主题呢。
 * 唉，如果是这样的就好了，遗憾的是，你无法选择何时在你的Java程序中出现的线程，仅仅是你自己没有启动线程并不代表
 * 你就可以回避编写使用线程的代码，例如，Web系统是最常见的Java应用系统之一，而基本的WEb库类，Servlet具有天生的
 * 的多线程-这很重要，因为Web服务器经常包含多个处理器，而并发是充分利用这些处理器的理想方式，图形化用应用户界面
 * 也是类似的情况，你将在22章中看到，尽管Swing和SWT类库都拥有针对线程安全的机制，但是不理解开发，就很难了解如何正确的
 * 使用它们。
 * java是一种多线程语言，并且提出了并发问题，不管你是否意识到了，因此，有很多使用中的java程序，要么只偶尔工作，要么
 * 在大多数的时间里工作，并且会由于未来发现缺陷而时不时的神秘崩溃，有时这种崩溃是温和的，但有时却意味着重要的数据丢失，
 * 并且如果没有意识到并发问题，你可能最终会认为问题出在其他的什么地方，而不在你的软件中，如果程序被没有意识到并发问题。
 * 你可能最给终会认为问题出在其他的什么地方，而不在你的软件中，如果程序迁移到多处理器系统中，这些种类的问题还会被
 * 暴露或放大，了解并发可以使你明显的意识到正确的程序会展示出不正确的行为。
 * 学习并发编程就像进入了一个全新的领域，有点类似学习一门新的编程语言，或者至少是学习了一整套新的语言概念，要理解并发编程
 * ，其难度与理解并发编程，其难度与理解面向对象编程的差不多，如果你花点几工夫，就能明白其基本的机制，但要想真正的掌握它的实质
 * ，就需要深入的学习和理解，本章的目标就是要让读者对并发的基本知识打下坚实的基础，从而能够理解其概念并编写出合理的多线程
 * 程序，注意，你可能很容易的变得过分自信，在你编写任何的复杂序列之前，应该学习一下专门的主题的书籍。
 *
 * 2，并发编程令人困惑的一个主要的原因是：使用并发编程时需要解决的问题有多个，而实现并发的方式也有多种，并且在这两者之间
 * 没有明显的映射关系，而且通常是一个模糊的界线，因此你必须理解有些问题和特例，以便有效的使用并发。
 * 用并发解决的问题的大体上可以分为 "速度"和设计管理的两种。
 *
 * 21.1.1 更快的执行
 * 速度问题听起来很简单，如果你要一个程序运行得更快，那么可以将其断开为多个片段，在单独的处理器上运行每个片段，并发是用于多个
 * 处理器基本的工具，当前，Moore定律己经有些过时了，至少对于传统的芯片是这样的，速度可以提高是以多核处理器形式而不是更快的
 * 的芯片的形式的出现的，为了使用程序运行得更快，你必须学习如何利用这些额外的处理器，而这正是并发赋予你的能力。
 *
 * 如果你有一台多处理机器，那要听么就可以在这些处理器之间分布多个任务，从而可以极大的提高吞量，这是使用强有力的多处理器Web服务器
 * 之间分布多个任务，从而可以极大地提高吞吐量，在每个请求分配一个线程中，程序中，它可以将大量的用户请求分布到CPU上。
 * 但是并发通常是提高运行的单处理器上的程序的性能。
 * 这听起来有些违背直觉，如果你仔细的考虑一下，就会发现，在单处理器上运行的并发程序开销确实应该比该程序的所有部分都顺序执行的开销
 * 大一些，因为其中增加了所谓上下切换的代价。
 * 使这个问题变得有些不同的是阻塞，如果程序中的某些任务因为该程序控制范围之外的某些条件而导致不能继续执行，那么我们就说任务或线程阻塞了
 * ，如果使用并来编写程序，那么当一个任务阻塞了，程序中的其他的部分还是可能执行的，因此程序可以保持继续执行，事实上，从性能的角度上来
 * 说，如果没有任务阻塞，那么在单处理器上使用并发并没有什么意义。
 * 在单处理器系统中的性能提高的常见示例是事件驱动编程，实际上，使用并发最吸引人的地方就是要产生具有可响应的用户界面，考虑这样的一个
 * 程序，它因为将执行，某些长期运行的操作，所以最终用户输入会被忽略，从而成为不可响应的程序，如果一个退出 按钮，那么你肯定不想在你写
 * 的每一段代码中都会检查它的状态，因为这会产生非常尴尬的代码，而我们也无法保证程序员不会忘记这种检查，如果不使用并发，则产生可响应的
 * 用户界面的唯一的方式，就是所有的任务都是检查用户的输入，通过创建单独的执行线程来响应用户的输入，即使这个线程的大多数时间里都会是
 * 阻塞的，但是程序可以保证具有一定程度的可响应性。
 *   程序需要连续的操作，并且同时需要返回对用户界面的控制，以便程序可响应用户，但是传统的方法在连续的执行其操作的同时，返回时程序其余部分
 * 控制，事实上，这听起来就像不可能的事情，好像CPU必须位于两处一样，但是这完全是并发造成的一种错觉，在多处理器中，这就只是一各幻觉了
 * 实现并发直接的方式是在操你系统级别使用进程，进程是运行它自己的地址空间内的自包容的程序，尽管这看起来每个程序其执行过程中歇歇停停，
 * 进程总是很吸引人，因为操作系统总是将进程之间相互隔离出来，因此它们之间不会相互干涉，这使得用进程编程相对而言比较容易一些，与此相反，
 * 像Java所使用的这种并发系统会共享诸如内存和I/O这样的资源，因此编写多线程程序最基本的困难在于协调不同的线程驱动的任务之间对这些资源的使用。
 * 以使用这些资源不会被同时被多个任务访问。
 *     这里有一个利用操作系统的简单的示例，在编写本书的时，我会规律的创建本书的当前的状态的多个冗余的备份副本，我会在本地的目录中保存一个
 * 副本，在Zip盘上的小程序用python的，但是的其概念是相同的，它会把本书压缩成一个文件，其文件名中带有版本号，然后执行操作的完成，但随后
 * 我意识到，每个复制的操作会储存介质I/O速度的不同而花费不同的时间，既然我在使用多任务操作系统，那就可以将每个复制操作当作单独的进程来
 * 启动，并让它们并行地运行，这样可以加速程序的执行速度，当一个进程受阻时，另一个进程可以继续向前运行。
 *      这是并发理想的示例，每个任务都作为进程在其自己的地址空间进行执行，因此任务之间根本不可能互相干涉，更重要是，对进程来说，它们之间'
 * 没有任何的彼此通信的需要，因为它们都是完全的独立的，操作系统会处理确保文件正确的复制的所有的细节，因此不会有个任何的风险，你可以获得更
 * 快的程序，并且完全的免费。
 *      有些人走得更远，提倡进程作为唯一的合理的并发方式，但遗憾的是，对进程常会有数量的和开销的限制，以避免它们在不同的并发系统之间的可
 * 应用性。
 *    某些编程被设计为可以将并发任务被设计为可能将并发任务彼此隔离,这些语言通常被称为函数型语言，其中每个函数调用都不会产生任何副作用。
 * 并因引而不能干涉其他的函数，并因此可以当作独立的任务来驱动，Erlang这类专门的并发语言业创建这个部分。
 *     Java采取了更加传统的方式，在顺序语言的基础上提供对线程的支持，与在多任务操作系统中分叉外部进程不同，线程机制是在由执行程序表示的
 * 单一的创建任务，这种方式产生的一个好处是操作系统的透明性，这对Java而言，是一个重要的设计目标，例如，在OSX之前Macintosh操作系统版本
 * Java第一个版本的一个非常重要的目标系统，不支持多任务，因此，除非Java中添加多线程机制，否则任何并发的Java程序都无法移动到Macintosh和
 * 类似的平台之上，这样就会打破，编写一次，到处运行的要求，
 *
 * 21.1.2 改进代码设计
 *      在单cPU机器上使用多任务的程序在什么问题时刻仍旧只在执行一项工作，因此从理论上来讲，肯定可以不用任何任务而编写出相同的程序，但是
 * 并发提供了一个重要的组织结构上的好处，你的程序设计可以极大的简化，某些类型的问题，例如仿真，没有并发的支持是很很难解决。
 *      大多数人都看到过至少一个形式的仿真，例如计算机游戏或电影中计算机生成的动画，仿真通常涉及许多交互式元素，每一个都有，其自己的想法，
 * 尽管你可能注意到这一点，在单处理器上，每个仿真的元素都是由这个处理器驱动执行的，从编程的角度来看，模拟每个仿真元素都有其中的自己的处理
 * 器并且，都是独立的任务，这种方式要容易得多。
 *      完整的仿真可能涉及非常大量的任务，这与仿真中的第个元素都可以独立的动作这一事实相对应，这其中包含门和岩石，而不仅仅只是精灵和
 * 巫师，多线程系统对可用的线程数量的限制通常都会是一个较少的数字，有时候数十或数百这样的数量级，这个数字在程序控制范围之外可能会发生
 * 变化，它可能依赖于java的版本，在java中，通常要假定你不会获得足够多的线程，从而使得可以为大型仿真中的每一元素提供一个线程。
 *      解决这个问题的典型方式是使用协作多线程，java的线程机制是抢占式的，这表示调试机制会周期性的中断线程，将上下文切换到另一个线程，
 * 从而为每个线程提供时间片，使得每个线程都会分配到数量合理的时间去驱动它的任务，在协作式系统中，每个任务都会自动地放弃控制，这要求程序
 * 员本有意识地在每个任务中插入某种类型的让步语句，协作式系统的优势是双重的，上下文切换的开销通常比抢占式的系统要低廉得多，并且对可以同时
 * 执行的线程数量在理论上没有任何限制，当你处理大理的仿真元素时，这可以一种理想的解决方案，但是注意的是，某些协作式系统并未设计为可以在多
 * 个处理器之间分布任务，这可能会是一种理想的解决方案。但是注意的是，某些协作式系统并未设计为可以在多个处理器之间分布任务，这可能会非常
 * 受限制。
 *      在另一个极端，当你用流行的消息系统工作时，由于消息系统涉及分布在整个网络中的多台独立的计算计，因此并发就会成为一种非常有用的模型
 * ，因为它是实际发生的模型，在这种情形中，所有的进程都彼此完全独立地运行，甚至没有任何可能对共亨资源，但是，你仍旧必须在进程间同步信息，
 * 使得整个消息系统不会丢失信息错误的时刻混进信息，即使你没有打算在眼前的大量的使用并发，理解并发也会很有用，因为你可以掌握基于消息机制的
 * 架构，这些架构在创建分布式系统时是更主要的方式。
 *      并发需要付出代价，包含复杂的性代价，但是这些代价与程序设计，资源负载均衡以及用户方便使用方面的改进相比，就显得微不足道了，通常，线程
 * 使用你能够创建更加松散耦合的设计，否则，你的代码中各个部分都必须显式地关注那些通常可以由线程来处理的任务。
 *      基本的线程机制
 *   并发编程使用我们可以将程序划分为多个分离的，独立运行的任务，通过使用多线程机制，这些独立的任务，也被称为子任务，中的每一个都将由执行
 *   线程来驱动，一个线程就是在进程中的一个单一的顺序控制流，因此，单个进程可以拥有多个并发执行的任务，但是你的程序使得每个任务都好像有其
 *   自己的CPU一样，其底层机制是切分CPU时间，但通常你不需要考虑它。
 *      线程模型为编程带来了便利，它简化了在单一程序中同时交织在一起的多个操作的处理，在使用线程时，CPU 将轮流给每个任务分配其占用时间，
 *  每个任务都觉得自己在一直占用CPU,但事实上CPU时间是划分成片段给了所有的任务，例外情况是程序确实运行在多个CPU之上。线程的一大好处是可以
 *  使你从这个层次抽身出来，即代码不必知道它是运行具有一个还是多个CPU的机器上，所以，使用线程机制是一种建立透明的，可扩展的程序的方法，如果
 *  程序运行得太慢，为机器增添一个CPU就能很容易的加快程序的运行速度，多任务和多线程往往是使用多处理器的最合理的方式。
 *  定义任务。
 *      线程可以驱动任务，因此你需要一种描述任务的方式，这可以由Runnable接口并编写run()方法，使得该任务可以执行你的命令，例如，下面的LiftOff
 *  任务将显示发射之前的倒计时：
 *符id
 *
 * 标识可以用来区分任务的多个实例，它是final的，因为它一旦被初始化之后，就不希望被修改
 *
 *
 *
 *
 *  1
 *
 *
 *
 *
 */
public class LiftOff implements Runnable {

    protected int countDown = 10; // Default

    private static int taskCount = 0;

    private final int id = taskCount++;

    public LiftOff() {


    }

    public LiftOff(int countDown) {

        this.countDown = countDown;

    }

    public String status() {
        return "#" + id + "(" +
                (countDown > 0 ? countDown : "Liftoff!") + "), ";
    }


    /***
     * 你更加有可能会看到任务的换进换出的证据
     *
     */

    public void run() {

        while (countDown-- > 0) {

            System.out.print(status());
            Thread.yield();

        }
    }



}




///:~
