package concurrency;//: concurrency/MainThread.java


/****
 *      标识符id可以用来区分任务的多个实例，它是final的，因为它一旦被初始化后就不希望被修改
 *      任务的run()方法通常总会有某种形式循环，使得任务一直运行下去不再需要，所以要设定跳出循环的条件 有一种
 *      选择是直接从run()返回，通常，run()被写成无限循环的形式，这就意味着，除非有某个条件使得run()终止，否则
 *      它将永远的运行下去，在本章后面将会看到如何安全的终止线程。
 *
 *
 *      在run()中对静态的方法Thread.yidld()的调用对线程高度器，java线程机制的一部分，可以将CPU从一个线程转移
 *  给另一个线程，的一种建议，它的声明，我己经执行完全生命的周期中最重要的部分了，此正是切换给其他的任务执行一段
 *  时间的大好时机，这完全是选择性的，但是这里使用它是因为它会在这些示例中产生更加有趣的输出，你更有可能会看到任务
 *  换进换出的证据。
 *      在下面的实例中，这个任务的run()不是由单独的线程驱动，它是在main()中直接调用的，实际上，这里仍旧使用线程
 *  即总是分配给main()的那个线程。
 *
 *
 */
public class MainThread {
    public static void main(String[] args) {
        LiftOff launch = new LiftOff();
        launch.run();
    }
} /* Output:
#0(9), #0(8), #0(7), #0(6), #0(5), #0(4), #0(3), #0(2), #0(1), #0(Liftoff!),
*///:~
