1. 众多的开源和非开源的项目


2.


3.


为会么要使用git
    本地建立版本库
    本地版本控制
    多主机异地协同工作
    重写提交说明
    有后悔药可以吃
    更好用的的提交列表
    更好的差异比较
    更完善的分支系统
    速度极快


版本库的初始化
    个人计算机从版本服务器同步

操作
    90%以上的操作在个人计算机上
    添加文件
    修改文件
    提交变更
    查看版本历史等
版本库同步
    将本地修改推送到版本服务器


直接记录快照，而非差异比较
近乎所有的操作都是在本地执行
时刻保持数据的完整性
多数操作仅添加数据
文件三种状态
    已修改（modified）
    已暂存 (staged)
    已提交 (committed)


Git文件
    已经被版本库管理的文件

已经修改
    在工作目录修改的Git文件


已暂存
    对已经修改的文件执行Git暂存操作，将文件存入暂存区

已提交
    将已经暂存文件执行Git提交操作，将文件存入版本库(是自己本机的版本库)

git rm 删除文件操作
    1.删除一个文件
    2.将被删除的文件纳入到暂存区（stage,index）
若想恢复被删除的文件，需要进行两个操作：
    git reset HEAD test2.txt        将待删除的文件从暂存区恢复到工作区
    git checkout -- test2.txt       将工作区中的修改丢弃掉

将test2.txt删除，这时，被删除的文件并没有添加到暂存区中，
如果要放入到暂存区中，我们要用git add 命令

git mv 命令 将当前这个目录移动到另一个目录
git mv test.txt text2.txt
git reset HEAD test2.txt
git checkout -- test2.txt



git add . 将当前目录的所有的文件纳入到暂存区中
git log
    -p :展示显示最近n次更新
    -n :仅显示每次提交的内容差异
    --stat: 仅显示知道要的增改行数据统计
    --pretty=online
    --pretty=format:"%h-%an,%ar:%s"

git help config
man git config
doc/*/*.txt
doc/**/*.txt    doc下的所有的.txt文件



我试图让每匹马都打印自己，但是之后的显示顺序取决于任务管理器，CyclicBarrier使得每匹
马都要执行为了向前移动时，CyclicBarrier将自动调用Runnable栅栏动作的任务，按有顺序
显示马和终点线的位置
    一旦所有的任务都越过了栅栏，它就会自动的为下一回合比赛作好准备
   为了展示这个非常简单的动画效果，你需要将控制台视窗的尺寸调整为小到只有马时，才会
展示出来
    boolean类型的数组checkedOut可以跟踪被签出的对象，并且可以通过getItem()和releaseItem()方法来
管理，而这些都将由Semaphoreo类型的available来加以确保，因此，在
chechOut中，如果没有任何信号量许可可用，这意味着池中没有更多的对象了，available将阻塞调用过程，在checkIn()中，
如果没有任何信号量许可证可用，这意味着在池中没有更多的对象了，available将阻塞调用过程，在checkoIn()中，如果
被徐的对象有效，则向信号量返回一个许可证
    为了创建一个示例，我们可以使用Fat，这是一种创建代价高昂的对象类型，因为它的构造器运行起来很耗时。
我们在池中管理这些对象，以限制这个构造器所造成的影响，我们可以创建一个任务，它将签出Fat对象，持有一段
时间之后再将它们签入，以此来测试Pool这个类
    在main()中，创建了一个持有Fat对象的Pool，而一组CheckoutTask则开始操练这个Pool，然后，main()
线程签出池中的Flat对象，但是并不签入他们，一旦池中所有的对象都被签出，Semaphore将不再允许执行任何签出操作
，blocked的run()方法因此会被阻塞，2秒钟之后，cancel()方法被调用，以此来挣脱Future的束缚，注意，冗余的签入将被
Pool忽略
    这个示例依赖Pool的客户端严格地并愿意签入所持有的对象，当其工作时，这时最简单的，
解决方案，如果你无法总是可以依赖于此，深入探讨了对已经签出对象池中的对象管理方式
    Exchanger是在两个任务之间单独的对象的栅栏，当这些任务进入栅栏时，它们各自拥有一个对象，
 当它们离开时，它们都拥有之前由对象持有的对象，Exchanger的典型应用场景是：一个任务在创建对象
 ，这些对象的生产代价高昂，而另一个任务在消费这些对象，通过这种方式，可以有更多的对象在被创建的同时被消费
 为了演练Exchanger类，我们将创建生产者的消费者的任务，它们经由泛型和Gennrator，可以工作于任何类型的对象，
 然后我们将差强人意应用于Fat类，ExchangerProducer和ExchangerConsumet使用了一个List<T>作为要交换的对象
 它们都包含一个这个List<T>的Exchanger，当你调用Exchanger.exchanger()方法，它将阻塞直至对方任务调用它自己的
 exchange()方法，那时，这两个exchanger()方法将全部完成，而List<T>则被互换
    在main()方法中，创建了用于两个任务的单一的Exchanger，以及两个用于互换的CopyOnWriterArrayList，这个特定ArrayList
 在main()中，创建了一个用于两个任务的单一的Exchanger，以及两个用于互换的CopyeOnWrite-ArrayList，这个特定的List变体允许
 在列表被遍历时调用Remove()方法，而不会抛出Concurrent-ModifycationExcetiopn异常，ExchangerProducer将填充这个List
 ，然后将这个满列表交换为ExchangerConsumer传递给它的空列表，因为有了Exchanger,填充一个列表和消费另一个列表便可以同时发生了
并发最有趣的也是最令人兴奋的就是创建仿真，通过使用并发構件都可以成為其自身的任务，这使得仿真，前面所示的HorseRace.java和GreenhouseSchedduler.java也可以被认为是仿真
银行出纳员仿真
    这个经典的仿真可以表示任何属于下面的这种类型的情况，对象随机的出现，并且要求数量有限的服务器提供随机数量的服务时间，通过构建仿真可能确定理想的服务器数量
 在本例中，每个银行顾客要求数量的服务时间，这是出纳员必须花费在顾客身上，以及服务顾客需求的时间单位的数量，服务时间的数量，服务时间的数量对每个
 顾客来说都是不同的，并且是随机的确定的，另外，你不知道每个时间间隔内有多少顾客会到达，因此这也是随机确定的
    Customer对象非常简单，只包含了一个final int 域，因为这些对象从来都不发生变化，因此它们只读对象，并且不需要同步或同时使用volatile，在这之上，每个
 Teller任务在任何时刻都只由一個任務訪問，
    CustomerLine表示顧客在等待被某個Teller用時所，因此Customer在任何时刻都由一个任务访问
    CustomerLine表示顾客在等待被某个teller服务时所排成的单一的行，这只是一个Array-BlockingQueue，它具有一个toString()方法，可以按照随机的时间
    间隔向这个队列中添加Customer.
    Teller从CustomerLine中取Customer，在任何时刻他都的时间向这个队列中添加按照我们希望的形式打印结果
    CustomerGenerator附着在只包含一个final int 域，因为这些对象从来都不发生变化，因此它们只读对象，并且不需要同步或使用volatile，在这之上每个Teller任务在任何时刻都
    只从输入队列中移除一个Cunstomer，并且在这个Custeomr上工作直到完成，因此Custeomr在任何时刻都只由一个任务访问
    ConstemerLine表示顾客 在等待被某个Teller服务时，在任何时刻他都只能处理一个顾客 ，并且跟踪在这个特定的班次中有他们服务的Customer的数量，当没有足够多的顾客时，他会被
    告知被执行doSometingElse()，而当出现了许多的顾客时，他会被告知去执行serveCustomerLine()，为了选择下一个出纳员，让其回到服务器的业务上，compareTo()方法将想看
    出纳员服务过的顾客数量，使得PriorityQueue可以自动地将工作量最小的出纳员向前台
    TellerManager是各种活动的中心，它跟踪所有的出纳员以及等会服务的顾客，这个仿真中有一件有趣的事情，并且跟踪在这个特定班次中有他们服务为了选择一个出纳员，让其回到服务
    业务顾客时，他会被告知服务顾客的业务上，compareTo方法将查看出纳员服务过的顾客数量，使得PriorityQueue可以自动的将工作量最小的出纳员推向前台
    adjustTellerNumber()中看到这一点，这是一个控制系统，它能够以稳定的方式不添加或移除出纳员，所有的控制系统都具有稳定性问题，如果它们对变化的反映过快，那么它们
    就是不稳定的，而如果它们反映过慢，则系统会迁移到它们某种极端的情况
    这个仿真添加了更多的仿真组件，如果Order和Plate,从而充实了本章的
    这是一种没有内部容量的阻塞队列，因此每个put()都必须等待一个take()，反之亦然，这就好像是你在把一个对象交给某个-没有任何虫子可以放置这个对象，因此只有在这个人伸出手
    准备好接收这个对象时，在本例中，SynchronousQue表示设置在用餐者的某个位置，以加强在任何时刻只能上一个菜这个概念
    关于这个示例，需要观察的一项非常而是经由队列互相恢复原状对象，接收任务将处理对象，将其当成一个消息来对待，而不是向它发送消息，如果只要可能遵循这项技术，那么你构建
    出健壮的并发系统可能性就会更加大增加
    下面的仿真示例将本章的许多的概念都结合在了一起，考虑一个假想的汽车的机器从组装线，每辆Car将多个阶段构建，从创建底盘开始，紧跟关的安装发动机，车厢和轮子
    Car是经由CarQue从一个地方送到另一个地方，CarQueue是一种LinkedBlocking-Queue类型，ChassisBuilder创建了一个未加修饰的Car,并将他们放到了一个CarQueue中，
    Assembler从一个CarQueue中取走Car，并雇请Robot对其加工，CyclicBarrier使Assembler等待，直至所有的Robot都完成，并且在那一时刻它会将Car放置到即将离开它的
    CarQueue中，然后被传送下一个操作，最终的CarQueue的消费都是一个Reproter对象，它只是打印Car，以显示所有的任务都已经正确的完成了
    Robot是在池中的管理的，当需要完成工作时，就会从池中雇请适当的Robot，在工作完成时，这个Robot会返回到池中
    在main()中创建了所有的必需对象，并初始化和个任务，最后启动ClassBuilder，从而启动整个过程，但是，由于LinkedBlokingQueue的行为，使得最先启动它的也没有问题，注意这个
    程序遵守了本章描述的所有的关于对象和任务生命周期的设计原则，因此关闭这个过程将是安全的。
        你会注意到，Car将其所有的谢谢老婆都设置成了synchronized的，正如它所表现出来的那样，在本例中，这是多余的，因为工厂的内部，Car是通过队列移动的，并且
     在任何时刻，只有一个任务能够在某辆车上工作，基本上队列可以强制串行化的访问Car,但是这个正是可能落入的陷阱，你可能会说，让我们尝试着通过不对的Car类同步来进行优化
     ，因为看起来Car这里并不需要同步，但是稍后，当这个系统连接到另一个需要Car被同步的系统时，它就会崩溃，
     Brian Goetz的注释
     进行这样的声明会简单得多，Car可能被多个线程使用，因此我们需要以明显的方式使其成
     为线程安全的，我把这这种方式描绘为在公园中，你会在陡峭的地坡路上发现一些保护围栏，
     并且可能会发现标记声明，不要做种围栏，当然，这条规则 的真实上的不是要阻止你借助围栏，而是防止你
     跌落悬崖，但是不要倚靠围栏，与不要跌落悬崖，相比，是一条遵循起来要容易得多的规则
     在java SE5的java.util.concurrent类库中存在着数量庞大的用于性能提高的类，当你细读concurrent类库时
     就会发现很难辨认话题来类
     既然java包括老式的synchronized关键字和java SE5中的新的Lock和Atomic类，那么较这些不同的方式，更多的理解它们各自的价值和适用范围，
     就显得很有意义
     比较天真的方式是在针对每种方式都执行一个简单的测试，就像下面这样
     注意，在AtomicTest中，我们发现情况过于复杂，使用Atomic对象已经不适合了，基本上，如果涉及多个Atomic对象，你就有可能会被强制要求放弃
     这种用法，转而使用更加常规的互斥jdk文件特别声明，当对一个对象的临界更新被限制为只涉及单个变量时，只有使用Atomic对象这种方式才能工作
     但是，这个测试仍旧保留了下来，使你能够感受到了Atomic对象的性能优势
     在main()中，测试是重复的运行的，并且你可以看到要求其重复次数起过5次，默认次数，对于每个交重复的，测试循环的数量都会加倍，因此你可以
     看到当运行测试越来越多时，这些不同的互斥行为方面存在着怎样的差异，正如你从输出中可以看到的那样，测试结果相当心人，对于前四次迭代，synchronized关键字
     看起来比使用Lock或Atomic要更加高效，但是突然间越过门槛，例如某些，记住，这个程序只给出了各种互斥方式之间的差异的趋势，而上面的输出也仅仅表示这些
     差异在我们特定的环境下的特定的机器上的表现，如你所见，如果自己动手实验，当所使用的线程数量不同，或者程序运行的时间更加长时，在行为方面肯定
     会存在的明显的变化，例如，某些hotspot运行时优化会在程序运行数分钟之后被调用，但是对于服务器程序，这段时间可能长达数小时
     也就是说，很明显，使用Locck通常会比使用synchronized要高效许多。而且synchronized的开销看起来变化范围太大，而Lock相比较一致
     这是否意味着你记过都不应该使用synchroze关键字呢，这里有两个因素要考虑，首先，在SynchroizationComparisions.java中，和维护方法的方法全是非常之小的
     ，通常，这是一个很好的习惯，只互斥那些你绝对必须互斥的部分，但是，在实际上是非常小的，通常，这是一个很好的中的那些大许多，因此在这些方法体中，花费的时间的百分比可能
     会明显的大于进入和退出互斥的开销，这样了就湮没了提高互斥的速度所带来的所有的好处，当然，唯一的了了解这一点的方式荒漠是当你对性能调优时，应该立即，尝试各种
     不同的方法来并观察它的造成的影响
     其次，阅读本章中的代码会发现，很明显，synchronized关键字所生产的代码，与LocK所需的，加锁tyr-finally解锁，惯用法所产生的代码相比，可读性提高了很多，这就是为什么本章
     主要使用synchroized的关键字的原因，就像我在本书其他的地方提到过的那样，代码被阅读的次数远多于空间小以编写的次数，在编程时，与其他的人交流而言，要重要得多
     ，因此代码的可读性至关重要，因此，以synchronize关键字入手，只有在性能调优进才替换为Lock对象这种做法，是具实际意义的。
     就像11间强调的那样，容器是所有的编程中的基础工具，这其中的自然也包括并发编程，出于这个原因，像Vector和Hashtable这类早期容器具有许多的sychronized
     ,当它用于非
     这些免锁容器背后能用策略是，对容器修改可以与读取操作同时发生的，只要读取者只能看到完成修改的结果即可，修改是在容器的数据结构的某个部分的一个
     单独的副本，有时整个数据结构的副本，上执行的，并且这个副本在修改过程中是不可视的，只有当修改完成时，被修改的结构才会自动地与主数据结构进行交换
     在CopyOnWriteArrayList中，写入将导致创建整个底层数组副本，而源数组将保留在原地使得复制的数组在修改时，读取的操作可以看到空上修改，CopyOnWriteArraylst
     乐观锁
     只要你从免锁容器中读取，那么它就会比其他的synchronized容器对应物快许多。因为获取和
 释放锁的开销被省掉了。如果需要向免锁容器中执行觉得少量的写入，那么情况仍旧会如此吗？但是会么算觉少量，这是一个意思的问题，本节将介绍有关在各种不同的条件下的
 ，这些容器在性能方面的差异的大致概念
    我将从一个泛型框架入手，它专门用于任何类型的容器上执行测试，包括各种map在内，其中泛型参数c表示容器的类型
    abstract方法containerInitializer()返回将被测试的初始化后的容器，它被存储在testContainer域中，另一个abstract方法tReadersAndWriters()启动读取者
    和写入的任务，它们将读取和修改待测试容器，不同的测试在运行时将具有数量的变化的读取都和写入者，就这样可以观察到锁的竞争针对synchronized容器而言，和写入
    针对免锁容器而言，的效果
    我们向容器提供了各种有关的测试的信息，参数标识符应该是自解释的，然后它会调用runTest()方法repetions次
    runTest()将创建一个CountDownLatch（）因此测试可以知道所有任何的时完成的，初始化容器，然后调用tReadersAndWriters()，并等待它们全部完成
    每个Reader和Writer类都基于TestTaks，它可以度量其抽象方法test()执行时间，然后在一个synchronized块中调用putResults()去存储度量结果
    为了使用这个框架其中的你可以识别也模版的设计模式，我们必须让想要测试特定的类弄容器继承Tester，并提供适合的Reader和Writer类
    abstract方法contrainerInitaialzer()返回将被测试的初始化后的容器，它被存储的testContainer域中，另一个abstract方法startReadersAndWriters()启动
    读取者和写入者的任务，它们将读取和修改的待测容器，不同的测试在运行时将具有数量的变量和读取者和写入者的，这样就可以观察到锁的竞争的针对synchronized容器而言
    和写入针对免锁容器而言的效果
    每个Reader和Writer类都基本TestTask，它可以度量其抽象方法test()执行时间，然后在一个synchroninzed()块中调用putResults()去存储度量结果
    为了使用这个框架其中你可以识别出模版方法设计模式，我们必须让想要测试的特定的类弄的容器继承Tester，并提供了适合的Reader和Writer类
    在ListTest中，Reader和Writer类执行针对List<Interger>的具体的动作，在Reader.putResults()中的，duration被存储起来，result也是一样的，这样可以防止这些计算
    被优化掉，startReadersAndWrites()被定义为创建和执行具体的Reader和Writers。
    一旦创建了ListTest，它就必须被进一步的继承，以覆盖containerInitaializer()，从而可以创建和初始化具体的测试容器
    在main()，你可以看球各种测试变体，它们具有数量的读取者和写入者，由于存在对Test.initMain(args )的调用，所以你可能使用命令行参数来改变测试变量
    默认的行为为每个测试运行10次，这有助于稳定的输出，而输出的可以变化的，因为存在诸如hotspot优化和垃圾回收这样的jvm活动，你看到的样本输出已经被编辑为只显示每个测试的
    最后的一个迭代，从输出中可以看到，synchronzied ArrayLis无论读取者和写入者的数量是多少，都具有大致相同的性能，读取者下其他的读取者，速度会快许多，并且在5个写入者时，速度
    仍旧明显地快，看起来你应该心理使用copyOnWriteArrayList,对列表写入的影响，并没有过超过做甚同步整个列表的影响。当有你必须在你的具体应用中尝试这两中不同的方式，以也了解到底
    哪个更加的好一些
    再交注意，这还一不是测试的结果绝对不变的良好的基准测试，你的结果几乎肯定是不同的，这里的目标只是让你对两中不同的类型的容器的相对行为有一个概念上的认识
    因为CopyOnWriteArraySet使用了CopyOnWriteArrayList，所以它的行为与此类似，在这里就不需要另外的设计一个单独的测试了
    比较各种map的实现
    我们可以测试使用相同的框架来得synchronziedHashMap和ConcuurentHashMap在性能方面的的比较结果
    如果compareAndSet()操作失败会发生什么，这正是棘手的问题，也是你在应用这项技术时的受限之处，即只有针对能够吻合的这些需要的问题
    如果comparentAndSet()失败，那么就必须决定做什么，这是一个非常重要的问题，因为如果不能执行某些恢复操作，那么你就不能使用这基技术
    从而必须使用传统的互斥，你可能会重试这个操作，如果在第二次操作，如果在第二次成功，那么万事大吉，或者可能会忽略这次失败，直接结束，在某些
    仿真中，如果数据点丢失，在重要的框架中，这就是最终需要做的事情，当然你必须很好的理解你的模型，以了解情况是否确实如此
    考虑一个假想的仿真，它由长度为30的30000000个基因构成，这可能是某种类型的遗传算法的起源，假设伴随着遗传算法的每次进化，都会发生某些代价高昂的
    计算，因此你决定使用一台多处理器来分布以提高性能，另外，你将使用aotomic对象而不是LOck对象来为防止互斥开销，当然 ，一开始，你使用
    synchronized关键字以最简单的方式来编写一个代码，一旦你运行该程序，发现它太慢了，并开始应用性能调优技术，而此时你也只能写了代码，一旦你运行该
    程序，发现它太慢了，并开始应用性能调优技术，而引时你也只能写出这样的代码的解决方案，只为你的模型的特性，使得如果在计算过程上产生了冲突，
    那么冲突的任务将直接的忽略它，并不会更新它的值。下面的示例的代码
        所有的元素被置于数组内，被认为有助于提高性能，这个假设将在一个练习中进行测试，每个Evolvoer对象会用它的前一个元素和后一个元素来平均它的值
    如果在更新时失败，那么将直接打印这个值，并继续执行，注意这个程序中没有出现任何的互斥
        FAstSimulation.java是否作出合理的假设，试着将数组普通的init修改为AtomicInterger，并使用Lock互斥，比较这两个版本中的程序差异

     ReaderWiteLock对向数据结构中相对不频繁地写入，但是有多个任务要经常读取这个数据结构的这个类的情况进行优化，ReadeWriterLoc使得你可以同时有多做点读取者
     ，只要它们都不试图写入即可，如果写入锁快马补骐了任务持有，那么任何读取者都不能访问，直至这个写锁被释放为止
     ReadWriteLock是否能够提高程序的性能是完全不确定的，它取决于诸如数据被读取的频率与被修改的额度，读取和写入操作的时间将更加复杂，因此短操作并不能带来好处。有多少线程
     竞争以及是否能够给你的程序带来好处的方式就是用试验来证明
        下面就是REAderWriteLock的最基本的用法示例
       REaderWriteList可以持有固定数量的任何类型的对象，你必须向构造器提供所希望的列表的尺寸和组装这个列表的时所用的初始对象，set()方法要获取一个写锁
       以调用底层的ArrayList.set()而get方法要获取一个读锁，以调用底层的ArrayList.get()另外，get()将检查是不已经有多个读取者的读锁，如果是，则将显示这种读取
       者的数量，以证明可以有多个读取者的读锁。
    为了测试REaderWriterList,ReaderWriterListTest为REaderWriterList<Integer>创建了读取通过修改MapComparingsons.java来调查它的性能，它是如何比较synchronized Hashmap和
    ConcurrentHashMap的
    当你通读本章之后，可能会发现，java中的线程机制看起来非常复杂并难以正确使用，另外，它好象 还有点达不到预期效果的味道，尽管多个任务可以并行工作，但是你必须花很大的气力
    去实现防止这些任务彼此互相干涉的技术
    如果你曾经编写过汇编语言，那么编写多线程就似曾相识，每个细节都很重要，你有责任处理所有的事物，并且没有任何编译器检查形式的安全防护措施
    有一种可替换的方式被称为活动对象或行动者，之所以这些对象是活动的，是因为每个对象都维护着它自己的工作器线程和消息队列，并且所有的这种对象的这种请求都
    将进入队列排队，任何时刻都只能运行其中一个，因此，有了活动对象，我们就可以串行化消息，而不是方法，这意味着不再需要防备一个任务在其循环的跟单被中断的这种问题了
    当你向一个活动对象发送消息时，这条消息会转变为了个任务，该任务会被插入到这个对象中的队列中，等待以后的某个时刻运行，java SE5的Futrure在实现这种模式中的派上用场，下面是一个
    简单的示例，它有两个方法，可以将方法调用排进队列
    当你向一个活动对象发送消息时，这条消息会转变为一个任务，该任务会被插入到这个对象中的队列中，等待在以后的某个时刻运行，java SE5的Future在实现这种模式时将派上用场
    下面是一个简单的示例，它有两个方法可以将方法排进队列
    由于对executors.newSingleThreadExecutor()的调用产生的单个线程执行器维护着它自己的无界阻塞队列，
    并且只有一个线程从该队列中取走任务并执行它们直到完成，我们需要在canculateInt()和calculateFloat()中做的就是用submit()提交一个新的Callable对象
    以响应对这些方法的调用，这样就可以把方法调用转变为消息，而submit(0的方法体包含在匿名内部类的call()方法中，注意，每个活动对象方法的返回值都是
    一个泛型参数的Future，而这个泛型参数就是该方法中实际的返回类型，通过这种方式，方法调用几乎可以立即返回，调用者可以使用future来发现何时任务完成，
    并收集实际的返回值，这样可以处理最复杂的情况，但是如果调用没有任何返回值，那么这个过程就将被简化
    在main()中，创建了一个List<Future<?>>来捕获由发送给活动对象的calculateFlota()和calculateInt()消息返回的Future对象，对于每个Future，都是使用isDone（）来
    从这个列表中抽取的，这种方式使得当Futrure完成并且其结果被处理过后，就会从List中移除，注意，使用CopyOnWriteArrayList可以移除为了防止ConCurrentModificationExcetiopn
    而复制List这种需求
    为了能够在不经意间就可以防止线程之间的耦合，任何传递给活动对象方法调用的参数都必须是只读的其他活动对象，或者是不连接对象，我的术语，即没有的连接任何其他任务的对象
    这一点很难强制保障，因为没有任何语言支持它，有了活动对象
    每个对象都可以拥有自己的工作器线程
    每个对象都将比肩迭迹对它自己的域全部控制权，这比普通的类要更加严苛一些，普通的类只在拥有防护他们的域的选择权）
    所有的活动对象之间的通信都将以在这些对象之间的消息形式发生
    活动对象之间的所有的消息都要排队
    这些结果很吸引人，由于从一个活动对象到另一个活动对象的消息只能被排队时的延迟所阻塞，
    并且因为这个延迟总是非常短且独立于任何其他对象的，所以发送消息实际上是不可阻塞的（最坏情况也只是很短的延迟），由于一个活动对象，所以发送消息实际上是不可阻塞的
    最坏情况是只是很短的延迟，由于一个活动元旦系统只是经由消息来通信，所以两个对象在竞争调用另一个对象上方法时，由于一个活动对象系统只是经由消息来通信，所以两个对象
    竞争调用另一个对象上方法时，是不会被阻塞遗憾的是，如果没有直接编译器支持，上面这种上编码领域，确实产生了进步，代码实际上就是活动对象，但是代码系统还

    确认收款信息
    展示给客户审批结论，并让用户填写借款方案，确认借款
    涉及接口
    试算接口    ：用户选择借款金额，借款期限时，机构告知我怀平台平台用户，应扣除到了账金额等信息
    推送用户确认收款信息接口：用户确认借款的金额，期限等信息，推送给机构进行申请确认
    推送用户难确认收款信息接口，用户输入收款确认验证码，借款的金额，期限等信息，推送给机构进行申请确认
    查询合同接口，展示机机的合同
    接口调用流程图如下
    还款信息页
    展示给客户还款的账单相关信息，还款金额，还款期数，还款时间，账单状态等等，让步用户进行申请还款
    涉及接口
    查询还款计划接口：我司平台将合作方机构发起请求，机构根据还款参数以及订单当前情况计算需要还款的总金额，已逾期金额，或者不可逾期金额，或者不可还款（失败）的原因
    推送用户还款信息接口：我司平台向今天什么机构推送还款验证码，还款数据
    查询还款状态接口：我司平台向今天什么机构查询还款申请的结果数据
    推送还款状态接口：合作机构给我司平台推送还款成功与否
    推送订单状态接口：用户还款之后，若订单状态扭转为已贷结清，合作机构需要将此状态推送给我司平台，若用户账单逾期，合作机构也需要将此状态推送给我司平台
    接口调用流程如下
    使用Post方式发送请求：请求数据使用json格式编码，Content-Type统一使用application/joon;charset=UTF-8类型
    除了明确说明外，请求和返回数据均为utf-8编码类型
    除明确说明外请求和返回数据均为utf-8类型
    code: 响应状态码，msg,响应信息描述，data:响应业务数据
    双方提供接口地址，我司平台调用机构，都要签名认证，
    双方提供接口地址调用，根据参数method派发到具体的处逻辑
    method取值参数接口列表说明，biz_data 业务数据参数接口详细说明
    把所有的参数按照名做字典排序
    以&符号key=val对，例如key1=val1&key2=val2记为str
    使用sha1WithRSAEncryption对侍签名串，str计算签名，并做base64编码，作为sign参数值会弹给接口服务方
    sign值参数与签名，参数不与签名
    合作机构和我平台互相换RSA公钥
    业务数据参数加密流程为
    以biz_data做正常的json编码后，使用DES算法ECB模式填充进行加密计算，DES密尔由双方各自随机生成，加密计算的结果biz_data值
    使用对方提供了RSA公钥对时DES加密算法使用进行加密，使用RSA加密加密，PKCS1填充，加密后的结果做base64编码，并作为des_key值
    业务数据解密流程为
    根据biz_enc参数判断biz_data业务的数据是否解密
    通过DES通过DES加密算法使用秘钥
    通过DES秘钥，使用DES算法ECB模式PKCS5填充对biz_data进行解密，得到业务参数
    测试环境
    注：测试环境域名端口求地址，请向我司提出申请，申请后邮件告知，将下属替换为测试环境测试环境域名及端口
    注意，在atomitTest中，我们发现情况过于复杂，使用Atomic对象是已经不适合了，基本上如果涉及多个Atomic对象
    你就有可能会被强制要求放弃这种用法，转而使用更加常规的互斥jdk应该可以的特别的声明，当对一个临界更新的被限制为
    你就有可能会被强制要求放弃这种用法，转而使用更加常规的互斥，jdk文档特别声明，当一个对象的更新被限制为只涉及单个变量时
    只有使用Atomic对象这种方式才能工作，但是，这个测试仍旧保留了下来，使你能够感受到Atomic对象的性能优势
    在main()中测试是重复运行的，并且你中以要求其重复次数超过5次，默认次数，对于每次重复测试，测试循环数量
    都会加倍，因此你可以看到当运行次数越来越多时，这些不同的互斥方面存在着怎样的差异，正如你从输出中可以看到的那样，测试结果相当心人
    至于前面四次迭代，synchronized关键字看起来比较使用Lock或Atomic要高效，但是突然间越过门槛值之后，synchronized关键字似乎变更非常
    低效，而Lock和Atomic则显得 大体维持着与BaseLine测试之间的比例关系，因此也就变得比synchronized关键字要高效得多
    记住伊能

       这个程序给出了各种互斥方式之间的差异的趋势，而上面的输出不也仅仅表示这些差异在我们特定的环境下的特定机器上的表现，如你所见
       ，如果自己动手试验，当所使用的线程数量不同时，或者程序运行的时间更长时，在行为方面的肯定存在着明显的变化，例如，某些不同的hotspot
       运行时优化会在程序运行数分钟之后被调用，但是对于服务器端程序，这段时间可能会长达数小时。
       也就是说，很明显，使用Lock通常会比使用Synchronized要高效许多，而且synchronze在开销看起来变化范围太大，而Locck相对比较一致
       这是否意味着你永远都不应该使用synchronized关键字呢，这里有两个因素需要考虑，首先在SynchronizeationCompaisions.java中互
       方法的方法体是非常之小的，通常，这是一个很好的习惯，只互斥那些你绝对必须互斥的部分，互斥方法的方法全是非常之小的，通常，这是一个很好的
       习惯是是否意味着你永远都不应该使用sychchronized关键字呢？这里有两个因素需要考虑，首先在SynchroinzetionComparisn.java中
       和维护方法的方法体是非常小的，通常，这是一个很好的习惯，只互斥那些绝对必须互斥的部分，但是，在实际中，被互斥的部分可能会比上面的
       示例中的大许多，因引在这些方法体中花费的时间的百分比可能会明显大于进入退出互斥的开销，这样了就湮没了提高互斥速度带来的所有的好处
      这么做的缺点就是，一些惯用的长词短句，也需要所有码都打出来
      其次阅读本章中的代码就会发现，很明显，synchronized关键字所产生的人代码，与LOck所需要的加锁try-finally解锁，惯用法所产生的代码
      相比，可读性提高了很多，这就是为什么本章应该要使用Siynchronized关键字的原因，就像我在配其他的地方提到的，代码被阅读的次数远多于被
      编写的次数，在编程时，与其他的交流相对于与计算机交流的而言，要重要得多，因此，以synchronize关键字入手，只有在性能调优时才替换时
      Lock对象这种做法是具有实际意义的。
      最后，当你在看书的并发程序中可以使用Atomic糎，这肯定是非常好，但是要意识到，正如我们在synchronizationComparisions.jav中所看到的
      Atomic对象只有在独立于其他所有的对象，要安全的做法是，以更加传统的互斥方式入手，只有在性能方面的要求能够明确指示时，再替换为Atomic

        setDefaultCloseOperation()告诉Jframe当用户执行关闭的操作时应该做些什么，Exit_ON_CLOSE常量它分退出程序，如果没有这个调用，
        默认行为是什么也不做的，因此应用将不会关闭，setSize()以象素为单位设置视察的尺寸，请注意最后一行
        frame.setvisible(true)
        如果没有这行，你在屏幕上将什么也看不到
        我们可以通过Jframe中添加一个JLable来使事情变得更加有趣一些
        在一秒钟之后，JLable的文本发生了变化，以尽管这对于这个小程序来说既有趣
        取面代之 提，其他的线程，例如这里像main()这样的线程，应该通过Swing事件分发线程的提交的执行的任务。你可以通过将任务提交给
        SwingUtilities.invokeLater()来实现这种方式，这个谢谢老婆会通过事件分发线程将任务放置到最终将得到执行的待执行事件队列中
        如果我们这种方式应用上面的示例，那么它就会变成下面的样子
        现在你再也不用直接操作Jalble了，取而代之的是，你提交一个Runnable，当事件分发线程在事件队列获取这项任务时，它将执行实际的
        操作，并且在执行这个代码都遵循这，就像上面的程序一样的，它应该向事件队列提交任务，因此 所有的编写的恰当的程序看起来应该是
        下面的样子，注意，对Sleep()的调用不在构造器的内部，如果你将它放在构造器的内部，JLable的初始文本就永远都不会出现，这主要是因为
       构造器在sleep()调用完毕和新的标签插入之前不会结束，如果Sleep()在构造器的内部，或者任何UI操作的内部，那么就意味着你在Sleep()期间将中止
       事件分发线程，通常是个糟糕的主意
       修改HelloSwing.java，向你自己证明如果没有对setDefaultCloseOperation()的调用，应用程序就不会关闭
       修改HelloSwing.java，通过添加随机数量的标签，说明标签添加的是动态的
       一个显示的框架
       我们可以创建一个显示的框架，将其用于本章剩余部分的Swing示例中，从而使得上面的想法得以结合，并减少了冗余的代码
       这可能是一个你想要自己的使用工具，因此它被放到了net.midview.utils类库中，要想使用它，你的应用就必须位于一个JFrame本书所有的
       不全都是如此，静态的run()方法可以将视窗的标题设置为类的简单名
       修改submitSwingPrograme.java让它使用SwingConsole
       创建一个按键非常简单，只要用你希望出现的按钮上的标签调用Jbutton的构造器即可，在后面你会看到一些更加有趣的功能，比如在按钮上的是显示图形
       一般来说，要在类中为按钮创建一个字段，以便以后可以引用这个按钮
       Jbutton是一个组件，综有自己的小窗口，能做为整个更新的过程的一部分而自动被我再给你，也就是谙，你不发显式绘制一个按钮或者别的类型的
       控件，只要所它们放在窗体上，它们可以自动绘制自己，通常你会在构造器内部把按钮加入窗体
       这里引入了一些新的内容，在向Frame添加任何组件之前，先给出一个新的FlowLayout类型的，布局管理器，布局管理器是面板用来
       但这里不能使用，在本章后面部分将学习它，因为它默认的先谈是第加入一个控件，将宋砺剑覆盖其他控件的，FlowLayOut使得控件可以在
       窗体上从左到右，从上到下连续均匀分布
       难如果在Button1.java没有setLayout()调用，那么就只有一个按钮会出所产生的程序中
       如果编译并运行前面的程序，那么当按下按钮的时候，会么也不会发生现在是必须常住进去编写一些代码以决定会履会么事情的时候了，事件
       驱动编程包含了许多关于GUI的内容的基础，就是把事件同处理事件的代码连接起来
       在Swing中，这种关联的方式式就是通过清楚的分离接口，图形组件和实现当和组件相关的事件发生时，你要执行的代码，所以，你要对诸如
       鼠标移动到按钮上，这样的事件不感兴趣的话，那么你不注册这样的事件就可以了，这种处理事件的驱动编程的方式非常直接和优雅
       一旦你不是你了其基本概念，就能名很容易的将其应用到甚至从未见过的Swing组件之上的，实际上，只要是JavaBean本章后面的讨论了，这个
       模式都适用了
       首先，对所使用的组件 ，我们只氢重点入在它感兴趣的主要事件上，对于Jbutton，感兴趣的事件就是按钮被按下，为了
       创建JtEXTField并把它放置在画面上的步骤，同Jbutton或者其他Swing组件所采用的步骤相同，这里与前面例子的不同之处在于创建
       一个ButtonLister对象，它实现了前面反映到过的ActionListencr接口，ActionPeromed()方法的参数是一个ActionEvent类型
       它包含事件和事件的源所有的信息，我假设使用类型转换，这个对象是Jubton，getText()方法返回按钮上的文本，这个文本被放进
       JextField，以证明当按钮按下的时候代码确实被调用过
       在构造器中，使用AddActionListener()方法业将ButtonListenr对象注册给两个按钮
       通常，所ActionListtner实现成匿名内部类，在构造器中使用addActionListem()方法来将ButtonLister对象注册给两个按钮
       通常，所ActionListern实现成匿名的内部类会更加方便，尤其在对每个监听器只使用一个实例的时候更是如此
       可以像下面的这们的修改Button2.java的这里使用一个匿名的内部类
       文本区域
       除了可以多行文本以及理多的功能不同之外 ，JEextArea下JextField在其他方面有很多的相似之处

        真是的，何苦回来的，他能死里逃生，该是一个统计学上的奇迹，该是一个率统计学是的奇迹，纯属意外，他们的家们都被
 龙卷风卷走了，幸亏有远方的亲戚把他救到了个安全的地方，扶养他大，他们告诉他们一些双亲的故事，拿一个照片给他，看，其中有几个只照
    幸亏有远方的亲戚把他，真像是个大讽刺，为什么这个地方满是灰尘呢
    不过他终于还回到这里，走进空无一物的房间，轻轻的听踮起脚尖，自己的呼吸声使得心虚，在这个房间里，冷冰冰的空气使人比平常更难以
    忍受，因为在死寂的气氛中没有一点安全感，顶楼后方一角有个柜子，柜子的门是开着的，他顿时觉得不安全起来，因为唯一留下来的家具
    ，他转身就想走，可是有一股力量硬是把他又拉了回来，他转身想走，可是有股力量硬是他又拉了回来，他无法抗拒，明明知道即将揭晓，一个
    赤的事实，但他还是用左手，好像是陌生人的似的，打开了门，最先看到的倒不怎样特别，柜子里的隔板积满了灰尘，间隔之间有
    顶楼后方一角有个柜子，柜子的门开着，因为这是唯一的留下的家具，他转身想走，可是有股力量硬是所他又拉了回来，他无法抗拒，明明知道
    赤裸裸的事实，但是他还是用左手，好象是陌生人似的打开了门
    最先看到的倒不是怎样的特别的，柜子里隔板积满了灰尘，间隔之间有浅色的条纹，笔直的，惨白的痕迹，连底墙板上也有，他突然之间明白了，
    书曾经放在这里，一排排的，都是他的，他童年时读，例如附了插图的希腊神话百科全书，儿童版，圣经，金银岛莎士比亚小说里查理士和玛莉的故事
    镀金封面印着小美人鱼书，以及有名的赛车收集簿，真是应用尽有。
    他费了点力才把门关上，拼命想忘记，但是就是忘记不了。这些丢失的书使他心痛，和书一同回忆起的还有一位长者，每晚在他睡前总会念
    段故事给他听，没有一个地方曾经旬这里这样保护他过他。
        我和良子女士时隔多年重逢，都为了对方的健在而高兴，良子女士我带来来梅干，梅干装着饭盒大小的密封容器里，好说，我带来的是大正十三年1924
    年的梅干，是母亲和父亲一起腌制的，父亲喜欢梅干，经常从院子里摘下梅子腌制，据说这是母亲嫁过去那一年腌制的，母亲死前对我说，如果你有机会
    见到勉先生，分送给他，良子女士说完，热泪盈眶，我默默的接过来了。，
        我回到轻井泽，已是深夜，取出一颗，放进嘴里，梅干在舌头上转运，我先感到了盐的味道，接着，在唾液的作用下，梅干变圆肯膨胀起来，最后是
        甘露般的清甜，我对这我现在了53年梅干感激涕零，
        我把这件事情写成了一篇小文章，发表在某报纸上的专栏上，一个年经的读者打电话来说，梅干能保存53年吗？不会烂吧。但是笑道说，作家的
    虚构的本事就是高，说罢，挂断电话
        我气愤了，便把和这个青年的对话以发表在专栏上，居住在小田原的尾崎一雄先生看到了这篇文章，写了如下短文发表在
     全读物，我的随笔栏
     其实，我家里还有嘉永三年1850年和明治四十一年1908年腌制的梅干，前者尾崎士郞的朋友高木德于昭和三十一年赠送的，后者是藤枝赠送氏的是地地道道
     的梅干
     我看到崎先生的文章，我不由得眼眶发热，打电话的那个年轻人是否会看到篇文章


     要构造器上，用国家及其首都名字来填充 Map, 注意，对于其中的两个按钮，因为程序中你不再需要引用监听器，所以直接创建 ActionListener 对象并添加
     ，而没有定义中间的变量，"Add Data" 按钮格式化并添加所有的数据，Clear Data 按钮使用 setText()方法来清理 JTextArea 中的所有的文本
     在 JextArea 被添加所有的数据，当屏幕中的文本太多的时候，用它来进行滚动控制，这么做就足够完整滚动功能，由于我曾试图在其他的 GUI 编程环境中得到类似功能，
     所以的我们对象 JScrollPane 这样的设计，使用简单的组印象非常深刻
    练习，使用 SwingConsole 编写一个应用程序，添加所有的具有 addActionListener()方法的 Swing 组件，（在 http://java.sun.com）的 JDK 文档中查找这个组件
    提示使用引功能搜索 addActionListener() 针对每个组件，捕获其事件，并在文本域中显示相应的信息
    在java中的所有的代码，组件放置在窗体上的方式可能与你使用的任何 GUI系统都不相同，首先它完全基于代码，没有用来控制组件布署的资源，第二，组件放置在窗体上的方式不是通过绝对
    坐标控制，而是由布局管理器，根据组件加入的有顺序决定其位置，使用不同的布局处理器，组件的大小，形状和位置将大不相同，此外，布局处理器还可以适应 applet 或
    JApplet，JFrame，JDiaLog,JPanel等都可以包含和显示组件，Container 中有一个称为 setLayout()方法，可以通过这个方法来选择不同的布局管理器还可以适应不同的
    这引进示例不会捕获任何按钮事件，因为它们仅仅是为了演示按钮是如何布局的
    除非你设置了其他的布局模式，否则 JFrame 将使用 BoarderLayout 人为默认的布局模式
    如果不加入其他的指令，它将的亲爱你调用 add()方法而加入的组件，把它设置在中央，然后所组件向各个方向拉伸，直到与边框对齐
    如果没有为组件指定放置的位置，默认情况下它将放置到中央
    在下面的示例中使用了默认的布局，因为默认的情况下 JFrame 使用的就是 BorderLayout
    它直接将组件 中从左到右流动到窗体上，直到占满上主的空间，然后两下移动一行，继续流动
    在下面的例子中，先氢布局管理器设置为 FlowLayout，然后在窗体上放最置按钮，你半注意到， 在使用 FlowLayout 的情况下，组件 将呈现出合适的大小，如果一个 Jbutton
    的大小就是其标签的大小
    在这个例子中有21个空位，但是加入了20个按钮，因为 CridLayout 并不进行，所以最后的一个空们将被闲置
    GridBagLayout 提供了强大的控制功能，包括精确的判断视窗区域如果布局，以及视窗大小的变化，变化的时候如果重新放置如果发现自己的设置非常复杂，
    作为一种可替换的摆地摊，你可能会考虑 TableLayout，它不属于 Swing 类库，但是可以从 http://java.sum.com 处下载，这个组件被设置于 GridBagLayout 之上，
    并且隐藏了其中多数细节，因为此可以极大的简化使用模式的方式
    绝对定位
        使用 setLayout方法所容器的布局管理器这位置为空
        为了每个组件调用 setBondds()或者 reshape 方法，取决于语言的版本，为方法传递以像素坐标为单位的边界矩形的参数，根据你要达到的目的
        可以在构造器或者 paint()方法中调用这些方法
        某些 GUI 构造工具大量使用这种方法，不过这通常不是生成代码的最佳方式
        由于人们在理解使用 GridBagLayout 时个遇到了很多的问题，所以 Swing 还提供了 BoxLayout，它具有 GridBagLayout 许多的好处，却不像 GriBagLayout 那么复杂
      所以当你需要手工的编写布局代码的时候，可能考虑使用它，再进提醒读者，如果你设计过于复杂的，所以当需要应用使用 GUI构造工具来生成布局人代码时，BoxLayout 使你可以在水平方向或者
      你可以在 ww.midViwe上的配在线补充材料中找到若干使用 BoxLayout 的基本示例
    最好的方式是什么
        Swing 的功能强大，用少数峰值代码就可以做很多事事情，基于产的上的，本书中的例子相当的简单，所以手工的编写它们很有意义，通过组合简单布局，就能得到非常多的结果
        不过，在某些情况下，手工编写 GUI 窗体就不太适合了，通过组合简单的布局，就能得到是非常多的结果，也不能充分利用编程的时间，java 和 Swing 的设计者最初的目的就是使得
        设计者最初上的就是一要使用语言和库能对 GUI 构造工具提供支持，创建这引进工具的明确的目的也是为了使用，创建这些工具的电脑有 的上的也是为了使用你理容易的获取编程经验
        只要理解了布局的方式以及如何处理事件，下面将学习，那怎么如果手工放置组件的细节就显得不那怎么重要了，应该让合适的工具帮你去做这些事件，毕竟设计 java 的上的是为了提高程序员的生产率
        在 Swing 的事件模型中，组件可以发起触发一个事件，每个事件的类型由不同的类型表示
        当事件被触发时，它将被一个或多个监听器接收，监听器多几天处理事件，所以，事件发生的地方可以与事件处理的地方的分离弄，既然是以这种方式使用 swing 组件，那么就只需要编写组件收到事件时
        将被调用的代码，所以这是一个分离的接口，与实现的极佳例子
        所谓的事件监听器，就是一个，实现特定类型的监听器接口，的类对象，所以程序员要做的就是，
        先创建一个监听器对象，然后所它注册到触发事件的组件，这个注册动作是通过调用触发事件的组件的 AddXXXListener()来完成的，这时用 XXX 表示监听器所监听的事件类型
            通过观察 addListener 方法的名称，就可以很容易的知道其能够处理的事件类型，要是你氢所监听的事件类型的搞错了，在编译期间就会发现有错误的，在本章的后面将学习到
            javaBean也是通过调用 addLinter方法名称来判断某个名称来某个 Bean 所以处理的事件类型
            然后，所有的事件处理逻辑都将置于监听器内部，要编写的一监听器，唯一要求就是必须实现相应的接口，可以创建一个全局的监听器，不过有时写成内部类会更加有用
            这不仅是因为将监听器类放在它们的所有的服务的用户接口类或者业务逻辑的内部时，可以在逻辑上对其进行分组，而这还是因为将在后面看到，内部类对象含有一个对其
    外部类对象的引用，这就是为了跨越类和子系统边界的调用提供了一种优雅的方式
    到目前为止，在本章的所有的例子中的已经使用 Swing 事件模型，本节余下的部分将补充这个模型的细节
    所有的 Swing 组件都具有 AdXXXListener()和 removeXXXListener()方法，这样就可以每个组件不回或移除相应类型的监听器，注意，每个方法的 XXX 还表示方法所能接收的参数
    比如 AddMyListener (MyListenerm)，下表包含相互关联的基本事件，监听器以及通过提供了 AddXXXListerne 和 removeXXXLister()方法来支持基本组件，记住，事件模型是可以
    扩展的，所有一会儿也许会遇到表格里，没有列出的事件和监听器
        在 name JEextField 中输入要查找的 Swing 组件类的名称，查找结果将要不用正则表达式进行匹配，最终结果显示JTextArea 中
        注意，这里没有使用按钮或者别的组件来表示你希望启动查找，这是由于JEextField 被 ActionListener 所监听，当你做出更改并按下
        回车的键后，列表马上就得到了更新，如果文本域的内容非空，将把此内容作为Class.forName（）的参数，以用来查找这个类，如果名称不正确，Class.forName()方法将失败
    即抛出异常， 这个异常将被捕获，并把JTextArea内容设置为 NoMatch 不不匹配，如果输入正确的名称，注意大小写，Class.forName()将成功回，然后返回 getMethod 方法将返回
    一个 Method 数组
    这里使用了两个正则表达式，第一个是 AddListter，它查找的模式为，以 add 开头，后面跟任意字母，然后接着 Listener()，最后是括号内的参数列表，注意，整个正则表达式用的是转义的
的括号包围，意思就是当发生匹配的时候，它呆以作为一个正则表达式用非转义，的括号包围，意思是当发生匹配的时候，这可以作为一个正则表达式组来访问，在NameL.actionPeroname()，通过
把每个 group(1)来选择第一个匹配包含在括号中的正则表达式组，这样得到的字符串仍然包含限定词，为了所限定词剔除掉，需要使用 qualifie Pattern 对象，这与 ShowMethods.java
中的做法，在构造器的未必，在name中设置一个初始值，然后触发事件，对初始数据进行一次测试，这个程序里查询 Swing 组件，这个程序为查询 Swing 组件所支持的事件类型提供了一种便利方式
这个程序为了查询 Swing 组件 所支持的事件类型提供了一种便利的方式，一旦你知道了某个组件支持哪些事件，不用勇者任何资料就可以处理这些事件了，你只要
    获取事件的类的名称，并移除单词 Event 然后将剩下的部分加上单词，Listener，得到了就是内部类必须实现监听器接口
    实现上面的接口，为要捕获的事件编写方法，比如，你可能要查找 鼠标移动，所以你可以为 MouseMotionListener 接口的 mouseMOved()方法编写代码，自然必须同时实现接口的其他方法，
    不过很快你会学到一种简单的方式
    为第二步编写的监听器类创建一个对象，然后通过调用方法向组件注册这个对象方法名-add 前缀加上监听器名称，比如 adMoseMotionListernr()
    这并不是个完整的列表，部分原因是由于事件模型允许你编写自己的事件类型的相应的监听器，所以，人们常常会遇到含有的定义事件的库，本章学习的知识可以帮助读者理解如何
    这个并不是个完整的列表，部分原因是由于事件模型允许你编写自己的事件类型和相应的监听器，所以，人们深深会遇到含有的自定义的事件库，本章学习到的知识可以帮助读者理解如果使用
    这些事件
    使用监听器适配器来进行简化
    在上面的表中可以发现，某些监听器接口有一个办法，这种接口听起来很简单，不过，多个方法监听器接口使用起来却不太方便，比如，如果你想捕获一个鼠标单击事件，例如，某个按钮还没有替换
    你捕获的该事件，那么就需要为 mouseClicked()方法编写代码，但是因为 mouseListener 是一个接口，所以尽管接口里的其他的方法来说你没有任何好处，但是你不是必须要实现所有的这些方法，这非常的
    烦人
    要解决这个问题，某些不是所有的，含有多个方法的监听器接口提供了相应的适配器，可以在上面的表中看到具体的名称，适配器为接口里的每个方法都提供了默认的空实现，现在你要做的就是从适配器来继承
    ，然后仅要修改这个方法，比如用典型的 MouseLister 像这样
    适配器的出发点就是为了编写监听器类变得更容易，不过，适配器也存在某种形式的缺陷，假设你写一个与前面类似的例子的 MouseAdapter
    这个适配器将不起作用，而且要想找到问题的根源也很困难，这足以让你定个与前面类似的 MouseAdapter
    这个适配器将不起作用出在方法，而且要想不起作用，而且要想找出问题的根源也非常困难，这足以让你发疯，因为除了鼠标标单击的时候方法没有被调用以外，程序的编译和运行都十分良好，你能发现这个问题吗？
    它将出在方法 名称上，这里一个名称是 MouseChicked()而没有写成 mouseClicked()这个简单的大小，写错误导致加入到了一个新的方法，它不是关闭视窗的时候所有的应该调用的方法。
    所有无法得到错误的导致加入了一个新的方法，它不是关闭视窗的时候应用调用方法，所以无法得到希望的结果，尽管使用接口不方便，但可以保证方法被有正确的实现
    想要保证实际上的确是覆盖了某个方法，一种改进的方法是在这段的代码的上面使用内建的注解
    跟踪多个事件
    作为一个有趣的试验，也为了向读者证明这引进事件确实可以触发，编写一个程序，使其能够跟踪 Jbutton 除了是否被按下，事件以外的行为，将显得很有价值，编写一个程序，使当然，这是一个受限的解决对象，
    因为 MyButton 被局限于只能与 TraceEvent 一起使用，这种情况有时称为高耦合代码
    在 Mybuttton 的构造器中，调用 SetBackgroupd()方法设置按钮的颜色，所有的监听器都是通过简单的方法调用进行注册的
    TrackEvent 类包含了一个 HashMap，它用来存放表示事件类型的字符串，以及些 JTextField，每个 JTexField 用来显示和相应事件的有关的信息，当然，这种对应关系可能静态生成而不用放进。
    当然，每个 JTextField 用来显示 和相应事件有关信息，当然，这种对应关系可以静态生成而不用放进 HashMap,不过我认为你会同使用和修改会容易得多，尤其是，如果要在 TrackEvent 中加入或删除新的事件类型
    ，那么只要在 Event 数组中加入了删除字符串其他工作将自动完成
    调用 report()调用的时候，将传给他由此可以，使用外部类中的 HashMap 对象 h 来查找与事件相关程序中事件发生时的实际情况
    使用 SwingConsole 编写一个 applet 应用程序，添加一个 JButton 和一个 JTextield，编写恰当的监听器，如果按钮获得了焦点，键入的字符出现在 JTextFilled里
    从 Jbbton 继承编写一个新的按钮按下的时候，将为按钮随机选择一种颜色，使用JButton 继承将按钮随机选择一种颜色，随机生成颜色，请参考，本章稍后，ColorBoxes.java
    通过加入处理新事件的代码，在 TrackEvent.java 中监听新事件，需要自己决定监听的事件类型
        既然已经理解了和事件模型，那么现在可以学习如何使用 Swing 组件了，本节将引导读者大致浏览一下 Swing组件，并介绍其最常用的功能，每个例子中都尽可能少，这样就很容易抽出所需代码，将其应用到自己的程序中。
    当程序变得复杂的时候，应该过渡使用 GUI 构造工具
    Swing 提供了许多的类型的按钮，所有的按钮，包括复选框，单选按钮，甚至菜单项，都从 AbstractButton，因为包含了菜单项，所有的将命名为 AbstractSelector，或者其他概括性的名字似乎更加恰当一些
    继承而来，很快你就会看到菜单项使用，下面的例子中演示了，当程序变得复杂的时候，应该过渡使用 GUI 构造工具
    Swing 提供了许多的类型的按钮，所有的按钮，包括复选框，单选框，甚至菜单项，都是从 AbstractButton，因为包含了菜单项，所以将其命名为 AbstractSelector 或者其他的概括性的名字似乎要更恰当一些，继承而来
    ，很快，你就会看到单项使用，下面的例子演示了几种按钮
    程序开始加入了来自 javax.swing.plaf.basic的 basicArrowoButton，然后又加入了几种不同的类型的按钮，运行例子，你会发现触发器按钮看起来差不多，也都是在开和关之间的切换，它们都从 JtoggleButto 继承再来
    按钮组也
    要想主单选按钮表现出某种排它的行为，必须把它们加入到一个按钮组 ButtonGroup 中不过，正如下面的例子中所演示的，任何 abstactButton 对象都可以加入到按钮给中。
    为了避免重复编写大量的代码，下面这个例子中使用了反射功能来产生几组不同类型的按钮，注意 makeBPanel()方法，它用来创建一个按钮组和一个 JPanel，此方法的第二个参数一个字段字符串数组
    ，铿 其中的的每个字符串上，将创建由珍上参数所代码的按钮实例，实例，然后将按钮实例，然后将此按钮加入 JPanel 中
    可以在 JLable 或者任何从 AbstrctButton 包括 JBtton，JcheckBox，JRadioButton 以及几种不同的类型，继承组件中的使用 Icon，和 JLable 一起使用 Icon 做法非常的直接后面有例子，
    下面的例子中还研究了按钮，或者从按钮继承组件，的基本使用图标的所有的形式
    可以使用任何想用的 GIF 文件，本例中使用来自于本书的源代码包，可以从 www.MindView.com 下载，要打开一个文件并且得到图形，只需要创建一个 ImageIcon对象并所文件名传递给它即可。
    然后，就能在程序中使用得到的图标了，可以使用任何使用的 GIF 文件，本例中使用的文件来自于本书的源代码包可以从下载，要打开一个文件并且得到图形，只需要创建一个 ImageIcon 对象并把
    文件传递给它即可，然后就能在程序中使用得到图标了
    许多不同的 Swing 组件的构造器都接受 Icon 类型的参数，也可以使用基本所要做的是，对于任何 JComponet 派生类的对象 jc,这样编写前面的例子中的按钮添加了一个工具提示，用来创建
    用户接口的类，绝大多数都是从 Jcompone 派生再来的，它们包含了一个 setToolTipTextString，方法，所以的，对于要放置在窗体上的组件，基本上所要做的就是，对于任何 Jcomponet 派生类的对象
    就像编写。
    当鼠标停留在这个 JCompnnet 的经过一预先的时间之后，下面的例子中演示了 JTextFild 组件 具有的其他功能

    俄罗斯冬宫陈列着的画作除了挂在墙壁上，橱窗上，还有大量的挂在天花析上，得低头观望，我找了一会脖子就酸痛了，便传到展厅中间的长凳上歇息，抬头看到对象很多的人物画，相框里面者是标准式的上身像
    ，四开报纸大小的画幅，横竖豆单的挂满了一面墙，店铺感觉奇怪的是，有的相框没有画像，仅在底端留有姓名和生卒年，，特别显眼，这是怎么回事，他们都是些什么人物，他们大多穿着旧式的华丽军服
    ，我下意识觉得他们是过去的英雄人物，但又不确定，就向中文讲解员求证
    讲解员是俄罗斯人，好介绍说，这样的人物画像墙冬宫里面有几十面，差不多每面都有几个空的，这些都是俄国近代以来在卫国战争，开疆拓土及进步事业中牺牲的或做出突出贡献的人，俄国比中国更早商业大亨人像
    油画，推崇把重要的人物的形象 留一下，统一保留，彰显历史，激励来人，有的人生前不曾留下画像，或突然殉职了，怎么办，不能随意虚构一张，就给他空留着，意即他在国家历史上是有空位的，
    底端写上他们的名字和生卒掉分，这样，自然地勾起人们缅怀的情思
    为什么称之为古老而又时兴的，设计理念，至于时兴，自然不必多说，看看国内外的大小的论坛上的当红讨论主题便知，至于古老，相信大家对下面图上的设备不会陌生
    这就是笔者的主要工作装备，IBM T40笔记本电脑一台，USB 硬盘和 U 盘符上面称为古老而不过分，再看看上例中的，笔记本与外围存储设备通过预先指定的一个接口，USB 相连，对于笔记本而言
    只是将用户指定的数据发送到 USb接口，而这些数据何去何从，则由当前接入的之后的想来这个例子可以帮助大家，如果把这里的 message属性换成一个数据字内存中的 Hello，字符跟踪对旬属性
    换成一个数据源，可能更加有感觉的 interfactB 的实现，如果获得 InterFaceB 实现类的实例，传统的方法在代码中创建 InterFaceB 实现类实例，并将赋予 ClzB

    这就是接口注入的最原始的雏形
    而对于一个 Type1型 IoC  容器而言，加载接口实现并创建其实例中的工作由容器完成，如 J2EE 开发中常用的 Context.lookup，都是 Type1型的 IOC表现形式
    可以看到在 Type2,类型的依赖注入机制中，依赖关系是通过类构造函数建立，容器通过调用类的构造方法，将其所需依赖关系注入其中
    PicoContainer 另一种实现了依赖注入模式的轻量的容器，首先实现了 Type2类型依赖注入模式
    在各种类型的依赖注入模式，设值注入机制更加直观，也更加自然，Quick Start 中的示例，就是典型的设置注入，即通过类 setter 方法未完成依赖关系的设置
    在笔者看来，基本设置模式依赖注入机制更加直观，也更加自然，Quit Start 中的示例中，就是典型类型设置，即通过类的setting 方法来完成依赖关系






















































