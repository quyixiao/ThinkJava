1. 众多的开源和非开源的项目


2.


3.


为会么要使用git
    本地建立版本库
    本地版本控制
    多主机异地协同工作
    重写提交说明
    有后悔药可以吃
    更好用的的提交列表
    更好的差异比较
    更完善的分支系统
    速度极快


版本库的初始化
    个人计算机从版本服务器同步

操作
    90%以上的操作在个人计算机上
    添加文件
    修改文件
    提交变更
    查看版本历史等
版本库同步
    将本地修改推送到版本服务器


直接记录快照，而非差异比较
近乎所有的操作都是在本地执行
时刻保持数据的完整性
多数操作仅添加数据
文件三种状态
    已修改（modified）
    已暂存 (staged)
    已提交 (committed)


Git文件
    已经被版本库管理的文件

已经修改
    在工作目录修改的Git文件


已暂存
    对已经修改的文件执行Git暂存操作，将文件存入暂存区

已提交
    将已经暂存文件执行Git提交操作，将文件存入版本库(是自己本机的版本库)

git rm 删除文件操作
    1.删除一个文件
    2.将被删除的文件纳入到暂存区（stage,index）
若想恢复被删除的文件，需要进行两个操作：
    git reset HEAD test2.txt        将待删除的文件从暂存区恢复到工作区
    git checkout -- test2.txt       将工作区中的修改丢弃掉

将test2.txt删除，这时，被删除的文件并没有添加到暂存区中，
如果要放入到暂存区中，我们要用git add 命令

git mv 命令 将当前这个目录移动到另一个目录
git mv test.txt text2.txt
git reset HEAD test2.txt
git checkout -- test2.txt



git add . 将当前目录的所有的文件纳入到暂存区中
git log
    -p :展示显示最近n次更新
    -n :仅显示每次提交的内容差异
    --stat: 仅显示知道要的增改行数据统计
    --pretty=online
    --pretty=format:"%h-%an,%ar:%s"

git help config
man git config
doc/*/*.txt
doc/**/*.txt    doc下的所有的.txt文件



我试图让每匹马都打印自己，但是之后的显示顺序取决于任务管理器，CyclicBarrier使得每匹
马都要执行为了向前移动时，CyclicBarrier将自动调用Runnable栅栏动作的任务，按有顺序
显示马和终点线的位置
    一旦所有的任务都越过了栅栏，它就会自动的为下一回合比赛作好准备
   为了展示这个非常简单的动画效果，你需要将控制台视窗的尺寸调整为小到只有马时，才会
展示出来
    boolean类型的数组checkedOut可以跟踪被签出的对象，并且可以通过getItem()和releaseItem()方法来
管理，而这些都将由Semaphoreo类型的available来加以确保，因此，在
chechOut中，如果没有任何信号量许可可用，这意味着池中没有更多的对象了，available将阻塞调用过程，在checkIn()中，
如果没有任何信号量许可证可用，这意味着在池中没有更多的对象了，available将阻塞调用过程，在checkoIn()中，如果
被徐的对象有效，则向信号量返回一个许可证
    为了创建一个示例，我们可以使用Fat，这是一种创建代价高昂的对象类型，因为它的构造器运行起来很耗时。
我们在池中管理这些对象，以限制这个构造器所造成的影响，我们可以创建一个任务，它将签出Fat对象，持有一段
时间之后再将它们签入，以此来测试Pool这个类
    在main()中，创建了一个持有Fat对象的Pool，而一组CheckoutTask则开始操练这个Pool，然后，main()
线程签出池中的Flat对象，但是并不签入他们，一旦池中所有的对象都被签出，Semaphore将不再允许执行任何签出操作
，blocked的run()方法因此会被阻塞，2秒钟之后，cancel()方法被调用，以此来挣脱Future的束缚，注意，冗余的签入将被
Pool忽略
    这个示例依赖Pool的客户端严格地并愿意签入所持有的对象，当其工作时，这时最简单的，
解决方案，如果你无法总是可以依赖于此，深入探讨了对已经签出对象池中的对象管理方式
    Exchanger是在两个任务之间单独的对象的栅栏，当这些任务进入栅栏时，它们各自拥有一个对象，
 当它们离开时，它们都拥有之前由对象持有的对象，Exchanger的典型应用场景是：一个任务在创建对象
 ，这些对象的生产代价高昂，而另一个任务在消费这些对象，通过这种方式，可以有更多的对象在被创建的同时被消费
 为了演练Exchanger类，我们将创建生产者的消费者的任务，它们经由泛型和Gennrator，可以工作于任何类型的对象，
 然后我们将差强人意应用于Fat类，ExchangerProducer和ExchangerConsumet使用了一个List<T>作为要交换的对象
 它们都包含一个这个List<T>的Exchanger，当你调用Exchanger.exchanger()方法，它将阻塞直至对方任务调用它自己的
 exchange()方法，那时，这两个exchanger()方法将全部完成，而List<T>则被互换
    在main()方法中，创建了用于两个任务的单一的Exchanger，以及两个用于互换的CopyOnWriterArrayList，这个特定ArrayList
 在main()中，创建了一个用于两个任务的单一的Exchanger，以及两个用于互换的CopyeOnWrite-ArrayList，这个特定的List变体允许
 在列表被遍历时调用Remove()方法，而不会抛出Concurrent-ModifycationExcetiopn异常，ExchangerProducer将填充这个List
 ，然后将这个满列表交换为ExchangerConsumer传递给它的空列表，因为有了Exchanger,填充一个列表和消费另一个列表便可以同时发生了
并发最有趣的也是最令人兴奋的就是创建仿真，通过使用并发構件都可以成為其自身的任务，这使得仿真，前面所示的HorseRace.java和GreenhouseSchedduler.java也可以被认为是仿真
银行出纳员仿真
    这个经典的仿真可以表示任何属于下面的这种类型的情况，对象随机的出现，并且要求数量有限的服务器提供随机数量的服务时间，通过构建仿真可能确定理想的服务器数量
 在本例中，每个银行顾客要求数量的服务时间，这是出纳员必须花费在顾客身上，以及服务顾客需求的时间单位的数量，服务时间的数量，服务时间的数量对每个
 顾客来说都是不同的，并且是随机的确定的，另外，你不知道每个时间间隔内有多少顾客会到达，因此这也是随机确定的
    Customer对象非常简单，只包含了一个final int 域，因为这些对象从来都不发生变化，因此它们只读对象，并且不需要同步或同时使用volatile，在这之上，每个
 Teller任务在任何时刻都只由一個任務訪問，
    CustomerLine表示顧客在等待被某個Teller用時所，因此Customer在任何时刻都由一个任务访问
    CustomerLine表示顾客在等待被某个teller服务时所排成的单一的行，这只是一个Array-BlockingQueue，它具有一个toString()方法，可以按照随机的时间
    间隔向这个队列中添加Customer.
    Teller从CustomerLine中取Customer，在任何时刻他都的时间向这个队列中添加按照我们希望的形式打印结果
    CustomerGenerator附着在只包含一个final int 域，因为这些对象从来都不发生变化，因此它们只读对象，并且不需要同步或使用volatile，在这之上每个Teller任务在任何时刻都
    只从输入队列中移除一个Cunstomer，并且在这个Custeomr上工作直到完成，因此Custeomr在任何时刻都只由一个任务访问
    ConstemerLine表示顾客 在等待被某个Teller服务时，在任何时刻他都只能处理一个顾客 ，并且跟踪在这个特定的班次中有他们服务的Customer的数量，当没有足够多的顾客时，他会被
    告知被执行doSometingElse()，而当出现了许多的顾客时，他会被告知去执行serveCustomerLine()，为了选择下一个出纳员，让其回到服务器的业务上，compareTo()方法将想看
    出纳员服务过的顾客数量，使得PriorityQueue可以自动地将工作量最小的出纳员向前台
    TellerManager是各种活动的中心，它跟踪所有的出纳员以及等会服务的顾客，这个仿真中有一件有趣的事情，并且跟踪在这个特定班次中有他们服务为了选择一个出纳员，让其回到服务
    业务顾客时，他会被告知服务顾客的业务上，compareTo方法将查看出纳员服务过的顾客数量，使得PriorityQueue可以自动的将工作量最小的出纳员推向前台
    adjustTellerNumber()中看到这一点，这是一个控制系统，它能够以稳定的方式不添加或移除出纳员，所有的控制系统都具有稳定性问题，如果它们对变化的反映过快，那么它们
    就是不稳定的，而如果它们反映过慢，则系统会迁移到它们某种极端的情况
    这个仿真添加了更多的仿真组件，如果Order和Plate,从而充实了本章的
    这是一种没有内部容量的阻塞队列，因此每个put()都必须等待一个take()，反之亦然，这就好像是你在把一个对象交给某个-没有任何虫子可以放置这个对象，因此只有在这个人伸出手
    准备好接收这个对象时，在本例中，SynchronousQue表示设置在用餐者的某个位置，以加强在任何时刻只能上一个菜这个概念
    关于这个示例，需要观察的一项非常而是经由队列互相恢复原状对象，接收任务将处理对象，将其当成一个消息来对待，而不是向它发送消息，如果只要可能遵循这项技术，那么你构建
    出健壮的并发系统可能性就会更加大增加
    下面的仿真示例将本章的许多的概念都结合在了一起，考虑一个假想的汽车的机器从组装线，每辆Car将多个阶段构建，从创建底盘开始，紧跟关的安装发动机，车厢和轮子
    Car是经由CarQue从一个地方送到另一个地方，CarQueue是一种LinkedBlocking-Queue类型，ChassisBuilder创建了一个未加修饰的Car,并将他们放到了一个CarQueue中，
    Assembler从一个CarQueue中取走Car，并雇请Robot对其加工，CyclicBarrier使Assembler等待，直至所有的Robot都完成，并且在那一时刻它会将Car放置到即将离开它的
    CarQueue中，然后被传送下一个操作，最终的CarQueue的消费都是一个Reproter对象，它只是打印Car，以显示所有的任务都已经正确的完成了
    Robot是在池中的管理的，当需要完成工作时，就会从池中雇请适当的Robot，在工作完成时，这个Robot会返回到池中
    在main()中创建了所有的必需对象，并初始化和个任务，最后启动ClassBuilder，从而启动整个过程，但是，由于LinkedBlokingQueue的行为，使得最先启动它的也没有问题，注意这个
    程序遵守了本章描述的所有的关于对象和任务生命周期的设计原则，因此关闭这个过程将是安全的。
        你会注意到，Car将其所有的谢谢老婆都设置成了synchronized的，正如它所表现出来的那样，在本例中，这是多余的，因为工厂的内部，Car是通过队列移动的，并且
     在任何时刻，只有一个任务能够在某辆车上工作，基本上队列可以强制串行化的访问Car,但是这个正是可能落入的陷阱，你可能会说，让我们尝试着通过不对的Car类同步来进行优化
     ，因为看起来Car这里并不需要同步，但是稍后，当这个系统连接到另一个需要Car被同步的系统时，它就会崩溃，
     Brian Goetz的注释
     进行这样的声明会简单得多，Car可能被多个线程使用，因此我们需要以明显的方式使其成
     为线程安全的，我把这这种方式描绘为在公园中，你会在陡峭的地坡路上发现一些保护围栏，
     并且可能会发现标记声明，不要做种围栏，当然，这条规则 的真实上的不是要阻止你借助围栏，而是防止你
     跌落悬崖，但是不要倚靠围栏，与不要跌落悬崖，相比，是一条遵循起来要容易得多的规则
     在java SE5的java.util.concurrent类库中存在着数量庞大的用于性能提高的类，当你细读concurrent类库时
     就会发现很难辨认话题来类
     既然java包括老式的synchronized关键字和java SE5中的新的Lock和Atomic类，那么较这些不同的方式，更多的理解它们各自的价值和适用范围，
     就显得很有意义
     比较天真的方式是在针对每种方式都执行一个简单的测试，就像下面这样
     注意，在AtomicTest中，我们发现情况过于复杂，使用Atomic对象已经不适合了，基本上，如果涉及多个Atomic对象，你就有可能会被强制要求放弃
     这种用法，转而使用更加常规的互斥jdk文件特别声明，当对一个对象的临界更新被限制为只涉及单个变量时，只有使用Atomic对象这种方式才能工作
     但是，这个测试仍旧保留了下来，使你能够感受到了Atomic对象的性能优势
     在main()中，测试是重复的运行的，并且你可以看到要求其重复次数起过5次，默认次数，对于每个交重复的，测试循环的数量都会加倍，因此你可以
     看到当运行测试越来越多时，这些不同的互斥行为方面存在着怎样的差异，正如你从输出中可以看到的那样，测试结果相当心人，对于前四次迭代，synchronized关键字
     看起来比使用Lock或Atomic要更加高效，但是突然间越过门槛，例如某些，记住，这个程序只给出了各种互斥方式之间的差异的趋势，而上面的输出也仅仅表示这些
     差异在我们特定的环境下的特定的机器上的表现，如你所见，如果自己动手实验，当所使用的线程数量不同，或者程序运行的时间更加长时，在行为方面肯定
     会存在的明显的变化，例如，某些hotspot运行时优化会在程序运行数分钟之后被调用，但是对于服务器程序，这段时间可能长达数小时
     也就是说，很明显，使用Locck通常会比使用synchronized要高效许多。而且synchronized的开销看起来变化范围太大，而Lock相比较一致
     这是否意味着你记过都不应该使用synchroze关键字呢，这里有两个因素要考虑，首先，在SynchroizationComparisions.java中，和维护方法的方法全是非常之小的
     ，通常，这是一个很好的习惯，只互斥那些你绝对必须互斥的部分，但是，在实际上是非常小的，通常，这是一个很好的中的那些大许多，因此在这些方法体中，花费的时间的百分比可能
     会明显的大于进入和退出互斥的开销，这样了就湮没了提高互斥的速度所带来的所有的好处，当然，唯一的了了解这一点的方式荒漠是当你对性能调优时，应该立即，尝试各种
     不同的方法来并观察它的造成的影响
     其次，阅读本章中的代码会发现，很明显，synchronized关键字所生产的代码，与LocK所需的，加锁tyr-finally解锁，惯用法所产生的代码相比，可读性提高了很多，这就是为什么本章
     主要使用synchroized的关键字的原因，就像我在本书其他的地方提到过的那样，代码被阅读的次数远多于空间小以编写的次数，在编程时，与其他的人交流而言，要重要得多
     ，因此代码的可读性至关重要，因此，以synchronize关键字入手，只有在性能调优进才替换为Lock对象这种做法，是具实际意义的。
     就像11间强调的那样，容器是所有的编程中的基础工具，这其中的自然也包括并发编程，出于这个原因，像Vector和Hashtable这类早期容器具有许多的sychronized
     ,当它用于非
     这些免锁容器背后能用策略是，对容器修改可以与读取操作同时发生的，只要读取者只能看到完成修改的结果即可，修改是在容器的数据结构的某个部分的一个
     单独的副本，有时整个数据结构的副本，上执行的，并且这个副本在修改过程中是不可视的，只有当修改完成时，被修改的结构才会自动地与主数据结构进行交换
     在CopyOnWriteArrayList中，写入将导致创建整个底层数组副本，而源数组将保留在原地使得复制的数组在修改时，读取的操作可以看到空上修改，CopyOnWriteArraylst
     乐观锁
     只要你从免锁容器中读取，那么它就会比其他的synchronized容器对应物快许多。因为获取和
 释放锁的开销被省掉了。如果需要向免锁容器中执行觉得少量的写入，那么情况仍旧会如此吗？但是会么算觉少量，这是一个意思的问题，本节将介绍有关在各种不同的条件下的
 ，这些容器在性能方面的差异的大致概念
    我将从一个泛型框架入手，它专门用于任何类型的容器上执行测试，包括各种map在内，其中泛型参数c表示容器的类型
    abstract方法containerInitializer()返回将被测试的初始化后的容器，它被存储在testContainer域中，另一个abstract方法tReadersAndWriters()启动读取者
    和写入的任务，它们将读取和修改待测试容器，不同的测试在运行时将具有数量的变化的读取都和写入者，就这样可以观察到锁的竞争针对synchronized容器而言，和写入
    针对免锁容器而言，的效果
    我们向容器提供了各种有关的测试的信息，参数标识符应该是自解释的，然后它会调用runTest()方法repetions次
    runTest()将创建一个CountDownLatch（）因此测试可以知道所有任何的时完成的，初始化容器，然后调用tReadersAndWriters()，并等待它们全部完成
    每个Reader和Writer类都基于TestTaks，它可以度量其抽象方法test()执行时间，然后在一个synchronized块中调用putResults()去存储度量结果
    为了使用这个框架其中的你可以识别也模版的设计模式，我们必须让想要测试特定的类弄容器继承Tester，并提供适合的Reader和Writer类
    abstract方法contrainerInitaialzer()返回将被测试的初始化后的容器，它被存储的testContainer域中，另一个abstract方法startReadersAndWriters()启动
    读取者和写入者的任务，它们将读取和修改的待测容器，不同的测试在运行时将具有数量的变量和读取者和写入者的，这样就可以观察到锁的竞争的针对synchronized容器而言
    和写入针对免锁容器而言的效果
    每个Reader和Writer类都基本TestTask，它可以度量其抽象方法test()执行时间，然后在一个synchroninzed()块中调用putResults()去存储度量结果
    为了使用这个框架其中你可以识别出模版方法设计模式，我们必须让想要测试的特定的类弄的容器继承Tester，并提供了适合的Reader和Writer类
    在ListTest中，Reader和Writer类执行针对List<Interger>的具体的动作，在Reader.putResults()中的，duration被存储起来，result也是一样的，这样可以防止这些计算
    被优化掉，startReadersAndWrites()被定义为创建和执行具体的Reader和Writers。
    一旦创建了ListTest，它就必须被进一步的继承，以覆盖containerInitaializer()，从而可以创建和初始化具体的测试容器
    在main()，你可以看球各种测试变体，它们具有数量的读取者和写入者，由于存在对Test.initMain(args )的调用，所以你可能使用命令行参数来改变测试变量
    默认的行为为每个测试运行10次，这有助于稳定的输出，而输出的可以变化的，因为存在诸如hotspot优化和垃圾回收这样的jvm活动，你看到的样本输出已经被编辑为只显示每个测试的
    最后的一个迭代，从输出中可以看到，synchronzied ArrayLis无论读取者和写入者的数量是多少，都具有大致相同的性能，读取者下其他的读取者，速度会快许多，并且在5个写入者时，速度
    仍旧明显地快，看起来你应该心理使用copyOnWriteArrayList,对列表写入的影响，并没有过超过做甚同步整个列表的影响。当有你必须在你的具体应用中尝试这两中不同的方式，以也了解到底
    哪个更加的好一些
    再交注意，这还一不是测试的结果绝对不变的良好的基准测试，你的结果几乎肯定是不同的，这里的目标只是让你对两中不同的类型的容器的相对行为有一个概念上的认识
    因为CopyOnWriteArraySet使用了CopyOnWriteArrayList，所以它的行为与此类似，在这里就不需要另外的设计一个单独的测试了
    比较各种map的实现
    我们可以测试使用相同的框架来得synchronziedHashMap和ConcuurentHashMap在性能方面的的比较结果
    如果compareAndSet()操作失败会发生什么，这正是棘手的问题，也是你在应用这项技术时的受限之处，即只有针对能够吻合的这些需要的问题
    如果comparentAndSet()失败，那么就必须决定做什么，这是一个非常重要的问题，因为如果不能执行某些恢复操作，那么你就不能使用这基技术
    从而必须使用传统的互斥，你可能会重试这个操作，如果在第二次操作，如果在第二次成功，那么万事大吉，或者可能会忽略这次失败，直接结束，在某些
    仿真中，如果数据点丢失，在重要的框架中，这就是最终需要做的事情，当然你必须很好的理解你的模型，以了解情况是否确实如此
    考虑一个假想的仿真，它由长度为30的30000000个基因构成，这可能是某种类型的遗传算法的起源，假设伴随着遗传算法的每次进化，都会发生某些代价高昂的
    计算，因此你决定使用一台多处理器来分布以提高性能，另外，你将使用aotomic对象而不是LOck对象来为防止互斥开销，当然 ，一开始，你使用
    synchronized关键字以最简单的方式来编写一个代码，一旦你运行该程序，发现它太慢了，并开始应用性能调优技术，而此时你也只能写了代码，一旦你运行该
    程序，发现它太慢了，并开始应用性能调优技术，而引时你也只能写出这样的代码的解决方案，只为你的模型的特性，使得如果在计算过程上产生了冲突，
    那么冲突的任务将直接的忽略它，并不会更新它的值。下面的示例的代码
        所有的元素被置于数组内，被认为有助于提高性能，这个假设将在一个练习中进行测试，每个Evolvoer对象会用它的前一个元素和后一个元素来平均它的值
    如果在更新时失败，那么将直接打印这个值，并继续执行，注意这个程序中没有出现任何的互斥
        FAstSimulation.java是否作出合理的假设，试着将数组普通的init修改为AtomicInterger，并使用Lock互斥，比较这两个版本中的程序差异

     ReaderWiteLock对向数据结构中相对不频繁地写入，但是有多个任务要经常读取这个数据结构的这个类的情况进行优化，ReadeWriterLoc使得你可以同时有多做点读取者
     ，只要它们都不试图写入即可，如果写入锁快马补骐了任务持有，那么任何读取者都不能访问，直至这个写锁被释放为止
     ReadWriteLock是否能够提高程序的性能是完全不确定的，它取决于诸如数据被读取的频率与被修改的额度，读取和写入操作的时间将更加复杂，因此短操作并不能带来好处。有多少线程
     竞争以及是否能够给你的程序带来好处的方式就是用试验来证明
        下面就是REAderWriteLock的最基本的用法示例
       REaderWriteList可以持有固定数量的任何类型的对象，你必须向构造器提供所希望的列表的尺寸和组装这个列表的时所用的初始对象，set()方法要获取一个写锁
       以调用底层的ArrayList.set()而get方法要获取一个读锁，以调用底层的ArrayList.get()另外，get()将检查是不已经有多个读取者的读锁，如果是，则将显示这种读取
       者的数量，以证明可以有多个读取者的读锁。
    为了测试REaderWriterList,ReaderWriterListTest为REaderWriterList<Integer>创建了读取通过修改MapComparingsons.java来调查它的性能，它是如何比较synchronized Hashmap和
    ConcurrentHashMap的
    当你通读本章之后，可能会发现，java中的线程机制看起来非常复杂并难以正确使用，另外，它好象 还有点达不到预期效果的味道，尽管多个任务可以并行工作，但是你必须花很大的气力
    去实现防止这些任务彼此互相干涉的技术
    如果你曾经编写过汇编语言，那么编写多线程就似曾相识，每个细节都很重要，你有责任处理所有的事物，并且没有任何编译器检查形式的安全防护措施
    有一种可替换的方式被称为活动对象或行动者，之所以这些对象是活动的，是因为每个对象都维护着它自己的工作器线程和消息队列，并且所有的这种对象的这种请求都
    将进入队列排队，任何时刻都只能运行其中一个，因此，有了活动对象，我们就可以串行化消息，而不是方法，这意味着不再需要防备一个任务在其循环的跟单被中断的这种问题了
    当你向一个活动对象发送消息时，这条消息会转变为了个任务，该任务会被插入到这个对象中的队列中，等待以后的某个时刻运行，java SE5的Futrure在实现这种模式中的派上用场，下面是一个
    简单的示例，它有两个方法，可以将方法调用排进队列
    当你向一个活动对象发送消息时，这条消息会转变为一个任务，该任务会被插入到这个对象中的队列中，等待在以后的某个时刻运行，java SE5的Future在实现这种模式时将派上用场
    下面是一个简单的示例，它有两个方法可以将方法排进队列
    由于对executors.newSingleThreadExecutor()的调用产生的单个线程执行器维护着它自己的无界阻塞队列，
    并且只有一个线程从该队列中取走任务并执行它们直到完成，我们需要在canculateInt()和calculateFloat()中做的就是用submit()提交一个新的Callable对象
    以响应对这些方法的调用，这样就可以把方法调用转变为消息，而submit(0的方法体包含在匿名内部类的call()方法中，注意，每个活动对象方法的返回值都是
    一个泛型参数的Future，而这个泛型参数就是该方法中实际的返回类型，通过这种方式，方法调用几乎可以立即返回，调用者可以使用future来发现何时任务完成，
    并收集实际的返回值，这样可以处理最复杂的情况，但是如果调用没有任何返回值，那么这个过程就将被简化
    在main()中，创建了一个List<Future<?>>来捕获由发送给活动对象的calculateFlota()和calculateInt()消息返回的Future对象，对于每个Future，都是使用isDone（）来
    从这个列表中抽取的，这种方式使得当Futrure完成并且其结果被处理过后，就会从List中移除，注意，使用CopyOnWriteArrayList可以移除为了防止ConCurrentModificationExcetiopn
    而复制List这种需求
    为了能够在不经意间就可以防止线程之间的耦合，任何传递给活动对象方法调用的参数都必须是只读的其他活动对象，或者是不连接对象，我的术语，即没有的连接任何其他任务的对象
    这一点很难强制保障，因为没有任何语言支持它，有了活动对象
    每个对象都可以拥有自己的工作器线程
    每个对象都将比肩迭迹对它自己的域全部控制权，这比普通的类要更加严苛一些，普通的类只在拥有防护他们的域的选择权）
    所有的活动对象之间的通信都将以在这些对象之间的消息形式发生
    活动对象之间的所有的消息都要排队
    这些结果很吸引人，由于从一个活动对象到另一个活动对象的消息只能被排队时的延迟所阻塞，
    并且因为这个延迟总是非常短且独立于任何其他对象的，所以发送消息实际上是不可阻塞的（最坏情况也只是很短的延迟），由于一个活动对象，所以发送消息实际上是不可阻塞的
    最坏情况是只是很短的延迟，由于一个活动元旦系统只是经由消息来通信，所以两个对象在竞争调用另一个对象上方法时，由于一个活动对象系统只是经由消息来通信，所以两个对象
    竞争调用另一个对象上方法时，是不会被阻塞遗憾的是，如果没有直接编译器支持，上面这种上编码领域，确实产生了进步，代码实际上就是活动对象，但是代码系统还

































